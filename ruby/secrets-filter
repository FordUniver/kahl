#!/usr/bin/env ruby
# frozen_string_literal: true

# Filter stdin: env lookup (precise labels) + pattern detection (catch-all).
# Streaming mode: processes line-by-line with immediate flush.
# State machine handles multiline private key blocks.
# Binary detection triggers passthrough.

# Auto-flush stdout
$stdout.sync = true

# Constants
STATE_NORMAL = 0
STATE_IN_PRIVATE_KEY = 1
MAX_PRIVATE_KEY_BUFFER = 100
LONG_THRESHOLD = 50

# Private key markers
PRIVATE_KEY_BEGIN = /-----BEGIN [A-Z ]*PRIVATE KEY-----/
PRIVATE_KEY_END = /-----END [A-Z ]*PRIVATE KEY-----/

# Known token patterns: [regex, label]
# Order: more specific patterns first
PATTERNS = [
  # GitHub
  [/ghp_[A-Za-z0-9]{36}/, 'GITHUB_PAT'],
  [/gho_[A-Za-z0-9]{36}/, 'GITHUB_OAUTH'],
  [/ghs_[A-Za-z0-9]{36}/, 'GITHUB_SERVER'],
  [/ghr_[A-Za-z0-9]{36}/, 'GITHUB_REFRESH'],
  [/github_pat_[A-Za-z0-9_]{22,}/, 'GITHUB_PAT'],

  # GitLab
  [/glpat-[A-Za-z0-9_-]{20,}/, 'GITLAB_PAT'],

  # Slack
  [/xoxb-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_BOT'],
  [/xoxp-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_USER'],
  [/xoxa-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_APP'],
  [/xoxs-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_SESSION'],

  # OpenAI / Anthropic
  [/sk-[A-Za-z0-9]{48}/, 'OPENAI_KEY'],
  [/sk-proj-[A-Za-z0-9_-]{20,}/, 'OPENAI_PROJECT_KEY'],
  [/sk-ant-[A-Za-z0-9-]{90,}/, 'ANTHROPIC_KEY'],

  # AWS
  [/AKIA[A-Z0-9]{16}/, 'AWS_ACCESS_KEY'],

  # Google Cloud
  [/AIza[A-Za-z0-9_-]{35}/, 'GOOGLE_API_KEY'],

  # age encryption
  [/AGE-SECRET-KEY-[A-Z0-9]{59}/, 'AGE_SECRET_KEY'],

  # Stripe
  [/sk_live_[A-Za-z0-9]{24,}/, 'STRIPE_SECRET'],
  [/sk_test_[A-Za-z0-9]{24,}/, 'STRIPE_TEST'],
  [/pk_live_[A-Za-z0-9]{24,}/, 'STRIPE_PUBLISHABLE'],

  # Twilio
  [/SK[a-f0-9]{32}/, 'TWILIO_KEY'],

  # SendGrid
  [/SG\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/, 'SENDGRID_KEY'],

  # npm / PyPI
  [/npm_[A-Za-z0-9]{36}/, 'NPM_TOKEN'],
  [/pypi-[A-Za-z0-9_-]{100,}/, 'PYPI_TOKEN'],

  # JWT tokens
  [/eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/, 'JWT_TOKEN'],

  # netrc/authinfo passwords (lookbehind)
  [/(?<=password )[^\s]+/, 'NETRC_PASSWORD'],
  [/(?<=passwd )[^\s]+/, 'NETRC_PASSWORD'],

  # Generic key=value patterns
  [/(?<=password=)[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
  [/(?<=password:)\s*[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
  [/(?<=Password=)[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
  [/(?<=Password:)\s*[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
  [/(?<=secret=)[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
  [/(?<=secret:)\s*[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
  [/(?<=Secret=)[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
  [/(?<=Secret:)\s*[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
  [/(?<=token=)[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],
  [/(?<=token:)\s*[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],
  [/(?<=Token=)[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],
  [/(?<=Token:)\s*[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],

  # Private keys (multiline regex for batch mode fallback)
  [/-----BEGIN [A-Z ]*PRIVATE KEY-----[\s\S]*?-----END [A-Z ]*PRIVATE KEY-----/, 'PRIVATE_KEY']
].freeze

# Classify a segment: N=digits, A=letters, X=mixed
def classify_segment(s)
  return '' if s.nil? || s.empty?
  return "#{s.length}N" if s.match?(/^\d+$/)
  return "#{s.length}A" if s.match?(/^[A-Za-z]+$/)

  "#{s.length}X"
end

# Describe token structure for redaction label
def describe_structure(s)
  return '' if s.nil?

  # Very long tokens: show length (with prefix hint if available)
  if s.length >= LONG_THRESHOLD
    ['-', '_', '.'].each do |sep|
      next unless s.include?(sep)

      parts = s.split(sep)
      first = parts[0]
      if first.match?(/^[a-zA-Z]+$/) || %w[ghp gho ghs ghr npm sk].include?(first)
        return "#{first}#{sep}...:#{s.length}chars"
      end
    end
    return "#{s.length}chars"
  end

  # Check for structured tokens
  ['-', '.', '_'].each do |sep|
    next unless s.include?(sep)

    parts = s.split(sep)
    next unless parts.length >= 2

    first = parts[0]
    if first.match?(/^[A-Za-z]+$/) && first.length <= 12
      segments = parts[1..].map { |p| classify_segment(p) }
      return "#{first}#{sep}#{segments.join(sep)}"
    end
    segments = parts.map { |p| classify_segment(p) }
    return segments.join(sep)
  end

  classify_segment(s)
end

# Load secrets from dotfiles
def load_secrets_from_dotfiles
  dotfiles = ENV['DOTFILES'] || File.join(ENV['HOME'], '.dotfiles')
  secrets_dir = File.join(dotfiles, 'secrets')

  return {} unless Dir.exist?(secrets_dir)

  secrets = {}
  begin
    output = `grep -rh '^[A-Z_][A-Z0-9_]*=' "#{secrets_dir}" 2>/dev/null`
    output.each_line do |line|
      if line =~ /^([A-Z_][A-Z0-9_]*)=/
        var = ::Regexp.last_match(1)
        val = ENV[var]
        secrets[var] = val if val && !val.empty?
      end
    end
  rescue StandardError
    # Ignore errors
  end

  secrets
end

# Replace known secret values with [REDACTED:VAR_NAME:structure]
def redact_env_values(text, secrets)
  # Sort by value length descending
  secrets.sort_by { |_, v| -v.length }.each do |var, val|
    next if val.nil? || val.empty?

    structure = describe_structure(val)
    replacement = "[REDACTED:#{var}:#{structure}]"
    text = text.gsub(val, replacement)
  end

  text
end

# Replace known token patterns
def redact_patterns(text)
  PATTERNS.each do |pattern, label|
    text = text.gsub(pattern) do |matched|
      structure = describe_structure(matched)
      "[REDACTED:#{label}:#{structure}]"
    end
  end

  # Git credential URLs: ://user:password@ -> ://user:[REDACTED]@
  text = text.gsub(%r{(://[^:]+:)([^@]+)(@)}) do
    prefix = ::Regexp.last_match(1)
    password = ::Regexp.last_match(2)
    suffix = ::Regexp.last_match(3)
    structure = describe_structure(password)
    "#{prefix}[REDACTED:GIT_CREDENTIAL:#{structure}]#{suffix}"
  end

  # Docker config auth: "auth": "base64" -> "auth": "[REDACTED]"
  text = text.gsub(/("auth":\s*")([A-Za-z0-9+\/=]{20,})(")/) do
    prefix = ::Regexp.last_match(1)
    auth = ::Regexp.last_match(2)
    suffix = ::Regexp.last_match(3)
    structure = describe_structure(auth)
    "#{prefix}[REDACTED:DOCKER_AUTH:#{structure}]#{suffix}"
  end

  text
end

# Redact a single line
def redact_line(line, secrets)
  line = redact_env_values(line, secrets)
  redact_patterns(line)
end

# Flush buffer with redaction
def flush_buffer_redacted(buffer, secrets)
  buffer.each do |line|
    print redact_line(line, secrets)
  end
end

# Main
def main
  secrets = load_secrets_from_dotfiles
  state = STATE_NORMAL
  buffer = []

  $stdin.each_line do |line|
    # Binary detection: null byte means binary data
    if line.include?("\0")
      flush_buffer_redacted(buffer, secrets) unless buffer.empty?
      buffer = []
      print line
      # Passthrough rest
      $stdin.each_line { |rest| print rest }
      return
    end

    case state
    when STATE_NORMAL
      if line.match?(PRIVATE_KEY_BEGIN)
        state = STATE_IN_PRIVATE_KEY
        buffer = [line]
      else
        print redact_line(line, secrets)
      end
    when STATE_IN_PRIVATE_KEY
      buffer << line

      if line.match?(PRIVATE_KEY_END)
        puts '[REDACTED:PRIVATE_KEY:multiline]'
        buffer = []
        state = STATE_NORMAL
      elsif buffer.length > MAX_PRIVATE_KEY_BUFFER
        flush_buffer_redacted(buffer, secrets)
        buffer = []
        state = STATE_NORMAL
      end
    end
  end

  # EOF: flush remaining buffer
  flush_buffer_redacted(buffer, secrets) unless buffer.empty?
end

main

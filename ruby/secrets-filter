#!/usr/bin/env ruby
# frozen_string_literal: true

# Filter stdin: env lookup (precise labels) + pattern detection (catch-all).
# Streaming mode: processes line-by-line with immediate flush.
# State machine handles multiline private key blocks.
# Binary detection triggers passthrough.
#
# Filter modes:
#   --filter=X or -f X (comma-separated: values, patterns, all)
#   SECRETS_FILTER_VALUES=0/false/no to disable values filter
#   SECRETS_FILTER_PATTERNS=0/false/no to disable patterns filter
#   Default: both enabled

require 'rbconfig'

# Auto-regenerate patterns if missing
script_dir = File.dirname(File.realpath(__FILE__))
patterns_gen = File.join(script_dir, 'patterns_gen.rb')
unless File.exist?(patterns_gen)
  system(RbConfig.ruby, File.join(script_dir, 'generate.rb')) or raise 'Failed to generate patterns'
end
require_relative 'patterns_gen'

# Auto-flush stdout
$stdout.sync = true

# Check if env value is falsy
def env_falsy?(val)
  return false if val.nil?

  %w[0 false no].include?(val.downcase.strip)
end

# Parse filter configuration from CLI args and environment
def parse_filters
  values_enabled = true
  patterns_enabled = true

  # Check for CLI --filter= or -f option
  cli_filter = nil
  i = 0
  while i < ARGV.length
    arg = ARGV[i]
    if arg.start_with?('--filter=')
      cli_filter = arg.sub('--filter=', '')
      break
    elsif arg == '-f' && i + 1 < ARGV.length
      cli_filter = ARGV[i + 1]
      break
    elsif arg == '--filter' && i + 1 < ARGV.length
      cli_filter = ARGV[i + 1]
      break
    end
    i += 1
  end

  if cli_filter
    # CLI overrides ENV entirely
    filters = cli_filter.split(',').map { |f| f.strip.downcase }
    valid_filters = []
    invalid_filters = []

    filters.each do |f|
      if %w[values patterns all].include?(f)
        valid_filters << f
      else
        invalid_filters << f
      end
    end

    # Warn about invalid filters
    invalid_filters.each do |f|
      warn "secrets-filter: unknown filter '#{f}', ignoring"
    end

    if valid_filters.empty?
      warn 'secrets-filter: no valid filters specified'
      exit 1
    end

    # Determine enabled filters
    if valid_filters.include?('all')
      values_enabled = true
      patterns_enabled = true
    else
      values_enabled = valid_filters.include?('values')
      patterns_enabled = valid_filters.include?('patterns')
    end
  else
    # Use ENV variables
    if ENV.key?('SECRETS_FILTER_VALUES')
      values_enabled = !env_falsy?(ENV['SECRETS_FILTER_VALUES'])
    end
    if ENV.key?('SECRETS_FILTER_PATTERNS')
      patterns_enabled = !env_falsy?(ENV['SECRETS_FILTER_PATTERNS'])
    end
  end

  { values: values_enabled, patterns: patterns_enabled }
end

# Constants from generated patterns
STATE_NORMAL = 0
STATE_IN_PRIVATE_KEY = 1
MAX_PRIVATE_KEY_BUFFER = PatternsGen::MAX_PRIVATE_KEY_BUFFER
LONG_THRESHOLD = PatternsGen::LONG_THRESHOLD

# Private key markers from generated patterns
PRIVATE_KEY_BEGIN = PatternsGen::PRIVATE_KEY_BEGIN
PRIVATE_KEY_END = PatternsGen::PRIVATE_KEY_END

# Combined patterns: direct + context + private key (for batch mode fallback)
PATTERNS = (
  PatternsGen::PATTERNS +
  PatternsGen::CONTEXT_PATTERNS +
  [[PatternsGen::PRIVATE_KEY_PATTERN, 'PRIVATE_KEY']]
).freeze

# Classify a segment: N=digits, A=letters, X=mixed
def classify_segment(s)
  return '' if s.nil? || s.empty?
  return "#{s.length}N" if s.match?(/^\d+$/)
  return "#{s.length}A" if s.match?(/^[A-Za-z]+$/)

  "#{s.length}X"
end

# Describe token structure for redaction label
def describe_structure(s)
  return '' if s.nil?

  # Very long tokens: show length (with prefix hint if available)
  if s.length >= LONG_THRESHOLD
    ['-', '_', '.'].each do |sep|
      next unless s.include?(sep)

      parts = s.split(sep)
      first = parts[0]
      if first.match?(/^[a-zA-Z]+$/) || %w[ghp gho ghs ghr npm sk].include?(first)
        return "#{first}#{sep}...:#{s.length}chars"
      end
    end
    return "#{s.length}chars"
  end

  # Check for structured tokens
  ['-', '.', '_'].each do |sep|
    next unless s.include?(sep)

    parts = s.split(sep)
    next unless parts.length >= 2

    first = parts[0]
    if first.match?(/^[A-Za-z]+$/) && first.length <= 12
      segments = parts[1..].map { |p| classify_segment(p) }
      return "#{first}#{sep}#{segments.join(sep)}"
    end
    segments = parts.map { |p| classify_segment(p) }
    return segments.join(sep)
  end

  classify_segment(s)
end

# Known secret env var names from generated patterns
EXPLICIT_SECRET_VARS = PatternsGen::EXPLICIT_ENV_VARS

# Suffixes that indicate a secret env var from generated patterns
SECRET_SUFFIXES = PatternsGen::ENV_SUFFIXES

# Load secrets from environment variables
def load_secrets
  secrets = {}

  ENV.each do |name, value|
    next if value.nil? || value.length < 8

    is_explicit = EXPLICIT_SECRET_VARS.include?(name)
    is_pattern = SECRET_SUFFIXES.any? { |suffix| name.end_with?(suffix) }

    secrets[name] = value if is_explicit || is_pattern
  end

  secrets
end

# Replace known secret values with [REDACTED:VAR_NAME:structure]
def redact_env_values(text, secrets)
  # Sort by value length descending
  secrets.sort_by { |_, v| -v.length }.each do |var, val|
    next if val.nil? || val.empty?

    structure = describe_structure(val)
    replacement = "[REDACTED:#{var}:#{structure}]"
    text = text.gsub(val, replacement)
  end

  text
end

# Replace known token patterns
def redact_patterns(text)
  PATTERNS.each do |pattern, label|
    text = text.gsub(pattern) do |matched|
      structure = describe_structure(matched)
      "[REDACTED:#{label}:#{structure}]"
    end
  end

  # Special patterns with capture groups (git credentials, docker auth, etc.)
  PatternsGen::SPECIAL_PATTERNS.each_value do |spec|
    text = text.gsub(spec[:pattern]) do
      secret_group = spec[:secret_group]
      secret_value = ::Regexp.last_match(secret_group)
      structure = describe_structure(secret_value)

      # Reconstruct with redacted secret
      parts = []
      (1..::Regexp.last_match.size - 1).each do |i|
        if i == secret_group
          parts << "[REDACTED:#{spec[:label]}:#{structure}]"
        else
          parts << ::Regexp.last_match(i)
        end
      end
      parts.join
    end
  end

  text
end

# Redact a single line
def redact_line(line, secrets, filters)
  line = redact_env_values(line, secrets) if filters[:values]
  line = redact_patterns(line) if filters[:patterns]
  line
end

# Flush buffer with redaction
def flush_buffer_redacted(buffer, secrets, filters)
  buffer.each do |line|
    print redact_line(line, secrets, filters)
  end
end

# Main
def main
  filters = parse_filters
  secrets = filters[:values] ? load_secrets : {}
  state = STATE_NORMAL
  buffer = []

  $stdin.each_line do |line|
    # Binary detection: null byte means binary data
    if line.include?("\0")
      flush_buffer_redacted(buffer, secrets, filters) unless buffer.empty?
      buffer = []
      print line
      # Passthrough rest
      $stdin.each_line { |rest| print rest }
      return
    end

    case state
    when STATE_NORMAL
      # Only use private key state machine if patterns filter is enabled
      if filters[:patterns] && line.match?(PRIVATE_KEY_BEGIN)
        state = STATE_IN_PRIVATE_KEY
        buffer = [line]
      else
        print redact_line(line, secrets, filters)
      end
    when STATE_IN_PRIVATE_KEY
      buffer << line

      if line.match?(PRIVATE_KEY_END)
        puts '[REDACTED:PRIVATE_KEY:multiline]'
        buffer = []
        state = STATE_NORMAL
      elsif buffer.length > MAX_PRIVATE_KEY_BUFFER
        flush_buffer_redacted(buffer, secrets, filters)
        buffer = []
        state = STATE_NORMAL
      end
    end
  end

  # EOF: flush remaining buffer
  flush_buffer_redacted(buffer, secrets, filters) unless buffer.empty?
end

main

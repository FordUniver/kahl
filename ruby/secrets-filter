#!/usr/bin/env ruby
# frozen_string_literal: true

# Filter stdin: env lookup (precise labels) + pattern detection (catch-all).
# Streaming mode: processes line-by-line with immediate flush.
# State machine handles multiline private key blocks.
# Binary detection triggers passthrough.
#
# Filter modes:
#   --filter=X or -f X (comma-separated: values, patterns, all)
#   SECRETS_FILTER_VALUES=0/false/no to disable values filter
#   SECRETS_FILTER_PATTERNS=0/false/no to disable patterns filter
#   Default: both enabled

# Auto-flush stdout
$stdout.sync = true

# Check if env value is falsy
def env_falsy?(val)
  return false if val.nil?

  %w[0 false no].include?(val.downcase.strip)
end

# Parse filter configuration from CLI args and environment
def parse_filters
  values_enabled = true
  patterns_enabled = true

  # Check for CLI --filter= or -f option
  cli_filter = nil
  i = 0
  while i < ARGV.length
    arg = ARGV[i]
    if arg.start_with?('--filter=')
      cli_filter = arg.sub('--filter=', '')
      break
    elsif arg == '-f' && i + 1 < ARGV.length
      cli_filter = ARGV[i + 1]
      break
    elsif arg == '--filter' && i + 1 < ARGV.length
      cli_filter = ARGV[i + 1]
      break
    end
    i += 1
  end

  if cli_filter
    # CLI overrides ENV entirely
    filters = cli_filter.split(',').map { |f| f.strip.downcase }
    valid_filters = []
    invalid_filters = []

    filters.each do |f|
      if %w[values patterns all].include?(f)
        valid_filters << f
      else
        invalid_filters << f
      end
    end

    # Warn about invalid filters
    invalid_filters.each do |f|
      warn "secrets-filter: unknown filter '#{f}', ignoring"
    end

    if valid_filters.empty?
      warn 'secrets-filter: no valid filters specified'
      exit 1
    end

    # Determine enabled filters
    if valid_filters.include?('all')
      values_enabled = true
      patterns_enabled = true
    else
      values_enabled = valid_filters.include?('values')
      patterns_enabled = valid_filters.include?('patterns')
    end
  else
    # Use ENV variables
    if ENV.key?('SECRETS_FILTER_VALUES')
      values_enabled = !env_falsy?(ENV['SECRETS_FILTER_VALUES'])
    end
    if ENV.key?('SECRETS_FILTER_PATTERNS')
      patterns_enabled = !env_falsy?(ENV['SECRETS_FILTER_PATTERNS'])
    end
  end

  { values: values_enabled, patterns: patterns_enabled }
end

# Constants
STATE_NORMAL = 0
STATE_IN_PRIVATE_KEY = 1
MAX_PRIVATE_KEY_BUFFER = 100
LONG_THRESHOLD = 50

# Private key markers
PRIVATE_KEY_BEGIN = /-----BEGIN [A-Z ]*PRIVATE KEY-----/
PRIVATE_KEY_END = /-----END [A-Z ]*PRIVATE KEY-----/

# Known token patterns: [regex, label]
# Order: more specific patterns first
PATTERNS = [
  # GitHub
  [/ghp_[A-Za-z0-9]{36}/, 'GITHUB_PAT'],
  [/gho_[A-Za-z0-9]{36}/, 'GITHUB_OAUTH'],
  [/ghs_[A-Za-z0-9]{36}/, 'GITHUB_SERVER'],
  [/ghr_[A-Za-z0-9]{36}/, 'GITHUB_REFRESH'],
  [/github_pat_[A-Za-z0-9_]{22,}/, 'GITHUB_PAT'],

  # GitLab
  [/glpat-[A-Za-z0-9_-]{20,}/, 'GITLAB_PAT'],

  # Slack
  [/xoxb-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_BOT'],
  [/xoxp-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_USER'],
  [/xoxa-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_APP'],
  [/xoxs-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_SESSION'],

  # OpenAI / Anthropic
  [/sk-[A-Za-z0-9]{48}/, 'OPENAI_KEY'],
  [/sk-proj-[A-Za-z0-9_-]{20,}/, 'OPENAI_PROJECT_KEY'],
  [/sk-ant-[A-Za-z0-9-]{90,}/, 'ANTHROPIC_KEY'],

  # AWS
  [/AKIA[A-Z0-9]{16}/, 'AWS_ACCESS_KEY'],

  # Google Cloud
  [/AIza[A-Za-z0-9_-]{35}/, 'GOOGLE_API_KEY'],

  # age encryption
  [/AGE-SECRET-KEY-[A-Z0-9]{59}/, 'AGE_SECRET_KEY'],

  # Stripe
  [/sk_live_[A-Za-z0-9]{24,}/, 'STRIPE_SECRET'],
  [/sk_test_[A-Za-z0-9]{24,}/, 'STRIPE_TEST'],
  [/pk_live_[A-Za-z0-9]{24,}/, 'STRIPE_PUBLISHABLE'],

  # Twilio
  [/SK[a-f0-9]{32}/, 'TWILIO_KEY'],

  # SendGrid
  [/SG\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/, 'SENDGRID_KEY'],

  # npm / PyPI
  [/npm_[A-Za-z0-9]{36}/, 'NPM_TOKEN'],
  [/pypi-[A-Za-z0-9_-]{100,}/, 'PYPI_TOKEN'],

  # JWT tokens
  [/eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/, 'JWT_TOKEN'],

  # netrc/authinfo passwords (lookbehind)
  [/(?<=password )[^\s]+/, 'NETRC_PASSWORD'],
  [/(?<=passwd )[^\s]+/, 'NETRC_PASSWORD'],

  # Generic key=value patterns
  [/(?<=password=)[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
  [/(?<=password:)\s*[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
  [/(?<=Password=)[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
  [/(?<=Password:)\s*[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
  [/(?<=secret=)[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
  [/(?<=secret:)\s*[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
  [/(?<=Secret=)[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
  [/(?<=Secret:)\s*[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
  [/(?<=token=)[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],
  [/(?<=token:)\s*[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],
  [/(?<=Token=)[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],
  [/(?<=Token:)\s*[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],

  # Private keys (multiline regex for batch mode fallback)
  [/-----BEGIN [A-Z ]*PRIVATE KEY-----[\s\S]*?-----END [A-Z ]*PRIVATE KEY-----/, 'PRIVATE_KEY']
].freeze

# Classify a segment: N=digits, A=letters, X=mixed
def classify_segment(s)
  return '' if s.nil? || s.empty?
  return "#{s.length}N" if s.match?(/^\d+$/)
  return "#{s.length}A" if s.match?(/^[A-Za-z]+$/)

  "#{s.length}X"
end

# Describe token structure for redaction label
def describe_structure(s)
  return '' if s.nil?

  # Very long tokens: show length (with prefix hint if available)
  if s.length >= LONG_THRESHOLD
    ['-', '_', '.'].each do |sep|
      next unless s.include?(sep)

      parts = s.split(sep)
      first = parts[0]
      if first.match?(/^[a-zA-Z]+$/) || %w[ghp gho ghs ghr npm sk].include?(first)
        return "#{first}#{sep}...:#{s.length}chars"
      end
    end
    return "#{s.length}chars"
  end

  # Check for structured tokens
  ['-', '.', '_'].each do |sep|
    next unless s.include?(sep)

    parts = s.split(sep)
    next unless parts.length >= 2

    first = parts[0]
    if first.match?(/^[A-Za-z]+$/) && first.length <= 12
      segments = parts[1..].map { |p| classify_segment(p) }
      return "#{first}#{sep}#{segments.join(sep)}"
    end
    segments = parts.map { |p| classify_segment(p) }
    return segments.join(sep)
  end

  classify_segment(s)
end

# Known secret env var names (explicit list)
EXPLICIT_SECRET_VARS = %w[
  GITHUB_TOKEN GH_TOKEN GITLAB_TOKEN GLAB_TOKEN BITBUCKET_TOKEN
  AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AZURE_CLIENT_SECRET
  OPENAI_API_KEY ANTHROPIC_API_KEY CLAUDE_API_KEY
  SLACK_TOKEN SLACK_BOT_TOKEN SLACK_WEBHOOK_URL
  NPM_TOKEN PYPI_TOKEN DOCKER_PASSWORD
  DATABASE_URL REDIS_URL MONGODB_URI
  JWT_SECRET SESSION_SECRET ENCRYPTION_KEY
  SENDGRID_API_KEY TWILIO_AUTH_TOKEN STRIPE_SECRET_KEY
].freeze

# Suffixes that indicate a secret env var
SECRET_SUFFIXES = %w[_SECRET _PASSWORD _TOKEN _API_KEY _PRIVATE_KEY _AUTH _CREDENTIAL].freeze

# Load secrets from environment variables
def load_secrets
  secrets = {}

  ENV.each do |name, value|
    next if value.nil? || value.length < 8

    is_explicit = EXPLICIT_SECRET_VARS.include?(name)
    is_pattern = SECRET_SUFFIXES.any? { |suffix| name.end_with?(suffix) }

    secrets[name] = value if is_explicit || is_pattern
  end

  secrets
end

# Replace known secret values with [REDACTED:VAR_NAME:structure]
def redact_env_values(text, secrets)
  # Sort by value length descending
  secrets.sort_by { |_, v| -v.length }.each do |var, val|
    next if val.nil? || val.empty?

    structure = describe_structure(val)
    replacement = "[REDACTED:#{var}:#{structure}]"
    text = text.gsub(val, replacement)
  end

  text
end

# Replace known token patterns
def redact_patterns(text)
  PATTERNS.each do |pattern, label|
    text = text.gsub(pattern) do |matched|
      structure = describe_structure(matched)
      "[REDACTED:#{label}:#{structure}]"
    end
  end

  # Git credential URLs: ://user:password@ -> ://user:[REDACTED]@
  text = text.gsub(%r{(://[^:]+:)([^@]+)(@)}) do
    prefix = ::Regexp.last_match(1)
    password = ::Regexp.last_match(2)
    suffix = ::Regexp.last_match(3)
    structure = describe_structure(password)
    "#{prefix}[REDACTED:GIT_CREDENTIAL:#{structure}]#{suffix}"
  end

  # Docker config auth: "auth": "base64" -> "auth": "[REDACTED]"
  text = text.gsub(/("auth":\s*")([A-Za-z0-9+\/=]{20,})(")/) do
    prefix = ::Regexp.last_match(1)
    auth = ::Regexp.last_match(2)
    suffix = ::Regexp.last_match(3)
    structure = describe_structure(auth)
    "#{prefix}[REDACTED:DOCKER_AUTH:#{structure}]#{suffix}"
  end

  text
end

# Redact a single line
def redact_line(line, secrets, filters)
  line = redact_env_values(line, secrets) if filters[:values]
  line = redact_patterns(line) if filters[:patterns]
  line
end

# Flush buffer with redaction
def flush_buffer_redacted(buffer, secrets, filters)
  buffer.each do |line|
    print redact_line(line, secrets, filters)
  end
end

# Main
def main
  filters = parse_filters
  secrets = filters[:values] ? load_secrets : {}
  state = STATE_NORMAL
  buffer = []

  $stdin.each_line do |line|
    # Binary detection: null byte means binary data
    if line.include?("\0")
      flush_buffer_redacted(buffer, secrets, filters) unless buffer.empty?
      buffer = []
      print line
      # Passthrough rest
      $stdin.each_line { |rest| print rest }
      return
    end

    case state
    when STATE_NORMAL
      # Only use private key state machine if patterns filter is enabled
      if filters[:patterns] && line.match?(PRIVATE_KEY_BEGIN)
        state = STATE_IN_PRIVATE_KEY
        buffer = [line]
      else
        print redact_line(line, secrets, filters)
      end
    when STATE_IN_PRIVATE_KEY
      buffer << line

      if line.match?(PRIVATE_KEY_END)
        puts '[REDACTED:PRIVATE_KEY:multiline]'
        buffer = []
        state = STATE_NORMAL
      elsif buffer.length > MAX_PRIVATE_KEY_BUFFER
        flush_buffer_redacted(buffer, secrets, filters)
        buffer = []
        state = STATE_NORMAL
      end
    end
  end

  # EOF: flush remaining buffer
  flush_buffer_redacted(buffer, secrets, filters) unless buffer.empty?
end

main

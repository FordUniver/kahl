#!/usr/bin/env bun
// secrets-filter: Filter stdin for secrets, redact with labels
// Streaming mode with state machine for private keys
// Binary detection triggers passthrough
//
// Filter modes:
//   --filter=values    - redact known secret values from environment
//   --filter=patterns  - redact regex patterns (token formats)
//   --filter=all       - shorthand for both (default)
//
// Environment variables (override with --filter):
//   SECRETS_FILTER_VALUES=0|false|no    - disable values filter
//   SECRETS_FILTER_PATTERNS=0|false|no  - disable patterns filter

const STATE_NORMAL = 0;
const STATE_IN_PRIVATE_KEY = 1;
const MAX_PRIVATE_KEY_BUFFER = 100;
const LONG_THRESHOLD = 50;

// Valid filter names
const VALID_FILTERS = new Set(['values', 'patterns', 'all']);
const FALSY_VALUES = ['0', 'false', 'no'];

// Parse filter configuration from CLI args and environment
function parseFilterConfig(): { values: boolean; patterns: boolean } {
  // Check CLI args first (--filter=X or -f X)
  const args = Bun.argv.slice(2);
  let cliFilters: string | null = null;

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('--filter=')) {
      cliFilters = arg.slice('--filter='.length);
      break;
    } else if (arg === '--filter' || arg === '-f') {
      if (i + 1 < args.length) {
        cliFilters = args[i + 1];
        break;
      }
    } else if (arg.startsWith('-f')) {
      // -fvalues style
      cliFilters = arg.slice(2);
      break;
    }
  }

  // If CLI specified, parse and use it (overrides ENV entirely)
  if (cliFilters !== null) {
    const parts = cliFilters.split(',').map(s => s.trim().toLowerCase()).filter(s => s.length > 0);
    const valid: string[] = [];
    const invalid: string[] = [];

    for (const part of parts) {
      if (VALID_FILTERS.has(part)) {
        valid.push(part);
      } else {
        invalid.push(part);
      }
    }

    // Warn about invalid filters
    for (const name of invalid) {
      console.error(`secrets-filter: unknown filter '${name}', ignoring`);
    }

    // Error if no valid filters
    if (valid.length === 0) {
      console.error('secrets-filter: no valid filters specified');
      process.exit(1);
    }

    // Determine enabled filters
    const hasAll = valid.includes('all');
    return {
      values: hasAll || valid.includes('values'),
      patterns: hasAll || valid.includes('patterns'),
    };
  }

  // No CLI args: check environment variables
  const valuesEnv = Bun.env.SECRETS_FILTER_VALUES;
  const patternsEnv = Bun.env.SECRETS_FILTER_PATTERNS;

  return {
    values: valuesEnv === undefined || !FALSY_VALUES.includes(valuesEnv.toLowerCase()),
    patterns: patternsEnv === undefined || !FALSY_VALUES.includes(patternsEnv.toLowerCase()),
  };
}

// Parse config at startup
const filterConfig = parseFilterConfig();

// Private key markers
const PRIVATE_KEY_BEGIN = /-----BEGIN [A-Z ]*PRIVATE KEY-----/;
const PRIVATE_KEY_END = /-----END [A-Z ]*PRIVATE KEY-----/;

// Known token patterns: [regex, label]
const PATTERNS = [
  // GitHub
  [/ghp_[A-Za-z0-9]{36}/g, 'GITHUB_PAT'],
  [/gho_[A-Za-z0-9]{36}/g, 'GITHUB_OAUTH'],
  [/ghs_[A-Za-z0-9]{36}/g, 'GITHUB_SERVER'],
  [/ghr_[A-Za-z0-9]{36}/g, 'GITHUB_REFRESH'],
  [/github_pat_[A-Za-z0-9_]{22,}/g, 'GITHUB_PAT'],

  // GitLab
  [/glpat-[A-Za-z0-9_-]{20,}/g, 'GITLAB_PAT'],

  // Slack
  [/xoxb-[0-9]+-[0-9A-Za-z-]+/g, 'SLACK_BOT'],
  [/xoxp-[0-9]+-[0-9A-Za-z-]+/g, 'SLACK_USER'],
  [/xoxa-[0-9]+-[0-9A-Za-z-]+/g, 'SLACK_APP'],
  [/xoxs-[0-9]+-[0-9A-Za-z-]+/g, 'SLACK_SESSION'],

  // OpenAI / Anthropic
  [/sk-[A-Za-z0-9]{48}/g, 'OPENAI_KEY'],
  [/sk-proj-[A-Za-z0-9_-]{20,}/g, 'OPENAI_PROJECT_KEY'],
  [/sk-ant-[A-Za-z0-9-]{90,}/g, 'ANTHROPIC_KEY'],

  // AWS
  [/AKIA[A-Z0-9]{16}/g, 'AWS_ACCESS_KEY'],

  // Google Cloud
  [/AIza[A-Za-z0-9_-]{35}/g, 'GOOGLE_API_KEY'],

  // age encryption
  [/AGE-SECRET-KEY-[A-Z0-9]{59}/g, 'AGE_SECRET_KEY'],

  // Stripe
  [/sk_live_[A-Za-z0-9]{24,}/g, 'STRIPE_SECRET'],
  [/sk_test_[A-Za-z0-9]{24,}/g, 'STRIPE_TEST'],
  [/pk_live_[A-Za-z0-9]{24,}/g, 'STRIPE_PUBLISHABLE'],

  // Twilio
  [/SK[a-f0-9]{32}/g, 'TWILIO_KEY'],

  // SendGrid
  [/SG\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, 'SENDGRID_KEY'],

  // npm / PyPI
  [/npm_[A-Za-z0-9]{36}/g, 'NPM_TOKEN'],
  [/pypi-[A-Za-z0-9_-]{100,}/g, 'PYPI_TOKEN'],

  // JWT tokens
  [/eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g, 'JWT_TOKEN'],

  // netrc/authinfo passwords (lookbehind)
  [/(?<=password )[^\s]+/g, 'NETRC_PASSWORD'],
  [/(?<=passwd )[^\s]+/g, 'NETRC_PASSWORD'],

  // Generic key=value patterns
  [/(?<=password=)[^\s,;"'\}\[\]]+/g, 'PASSWORD_VALUE'],
  [/(?<=password:)\s*[^\s,;"'\}\[\]]+/g, 'PASSWORD_VALUE'],
  [/(?<=Password=)[^\s,;"'\}\[\]]+/g, 'PASSWORD_VALUE'],
  [/(?<=Password:)\s*[^\s,;"'\}\[\]]+/g, 'PASSWORD_VALUE'],
  [/(?<=secret=)[^\s,;"'\}\[\]]+/g, 'SECRET_VALUE'],
  [/(?<=secret:)\s*[^\s,;"'\}\[\]]+/g, 'SECRET_VALUE'],
  [/(?<=Secret=)[^\s,;"'\}\[\]]+/g, 'SECRET_VALUE'],
  [/(?<=Secret:)\s*[^\s,;"'\}\[\]]+/g, 'SECRET_VALUE'],
  [/(?<=token=)[^\s,;"'\}\[\]]+/g, 'TOKEN_VALUE'],
  [/(?<=token:)\s*[^\s,;"'\}\[\]]+/g, 'TOKEN_VALUE'],
  [/(?<=Token=)[^\s,;"'\}\[\]]+/g, 'TOKEN_VALUE'],
  [/(?<=Token:)\s*[^\s,;"'\}\[\]]+/g, 'TOKEN_VALUE'],

  // Private keys (multiline regex for batch mode fallback)
  [/-----BEGIN [A-Z ]*PRIVATE KEY-----[\s\S]*?-----END [A-Z ]*PRIVATE KEY-----/g, 'PRIVATE_KEY'],
];

// Classify a segment: N=digits, A=letters, X=mixed
function classifySegment(s) {
  if (!s || s.length === 0) return '';
  if (/^\d+$/.test(s)) return `${s.length}N`;
  if (/^[A-Za-z]+$/.test(s)) return `${s.length}A`;
  return `${s.length}X`;
}

// Describe token structure for redaction label
function describeStructure(s) {
  if (!s) return '';

  // Very long tokens: show length (with prefix hint if available)
  if (s.length >= LONG_THRESHOLD) {
    for (const sep of ['-', '_', '.']) {
      if (s.includes(sep)) {
        const parts = s.split(sep);
        const first = parts[0];
        if (/^[a-zA-Z]+$/.test(first) || ['ghp', 'gho', 'ghs', 'ghr', 'npm', 'sk'].includes(first)) {
          return `${first}${sep}...:${s.length}chars`;
        }
      }
    }
    return `${s.length}chars`;
  }

  // Check for structured tokens
  for (const sep of ['-', '.', '_']) {
    if (s.includes(sep)) {
      const parts = s.split(sep);
      if (parts.length >= 2) {
        const first = parts[0];
        if (/^[A-Za-z]+$/.test(first) && first.length <= 12) {
          const segments = parts.slice(1).map(classifySegment);
          return `${first}${sep}${segments.join(sep)}`;
        }
        return parts.map(classifySegment).join(sep);
      }
    }
  }

  return classifySegment(s);
}

// Load secrets from environment variables
function loadSecrets() {
  const secrets = new Map();

  const explicit = new Set([
    'GITHUB_TOKEN', 'GH_TOKEN', 'GITLAB_TOKEN', 'GLAB_TOKEN', 'BITBUCKET_TOKEN',
    'AWS_SECRET_ACCESS_KEY', 'AWS_SESSION_TOKEN', 'AZURE_CLIENT_SECRET',
    'OPENAI_API_KEY', 'ANTHROPIC_API_KEY', 'CLAUDE_API_KEY',
    'SLACK_TOKEN', 'SLACK_BOT_TOKEN', 'SLACK_WEBHOOK_URL',
    'NPM_TOKEN', 'PYPI_TOKEN', 'DOCKER_PASSWORD',
    'DATABASE_URL', 'REDIS_URL', 'MONGODB_URI',
    'JWT_SECRET', 'SESSION_SECRET', 'ENCRYPTION_KEY',
    'SENDGRID_API_KEY', 'TWILIO_AUTH_TOKEN', 'STRIPE_SECRET_KEY',
  ]);

  const suffixes = ['_SECRET', '_PASSWORD', '_TOKEN', '_API_KEY', '_PRIVATE_KEY', '_AUTH', '_CREDENTIAL'];

  const env = Bun.env;
  for (const [name, value] of Object.entries(env)) {
    if (!value || value.length < 8) continue;

    if (explicit.has(name) || suffixes.some(s => name.endsWith(s))) {
      secrets.set(name, value);
    }
  }

  return secrets;
}

// Replace known secret values with [REDACTED:VAR_NAME:structure]
function redactEnvValues(text, secrets) {
  if (secrets.size === 0) return text;

  // Sort by value length descending
  const sorted = [...secrets.entries()].sort((a, b) => b[1].length - a[1].length);

  for (const [varName, val] of sorted) {
    if (!val) continue;
    const structure = describeStructure(val);
    const replacement = `[REDACTED:${varName}:${structure}]`;
    text = text.split(val).join(replacement);
  }

  return text;
}

// Replace known token patterns
function redactPatterns(text) {
  for (const [pattern, label] of PATTERNS) {
    // Reset regex lastIndex for global patterns
    pattern.lastIndex = 0;
    text = text.replace(pattern, (matched) => {
      const structure = describeStructure(matched);
      return `[REDACTED:${label}:${structure}]`;
    });
  }

  // Git credential URLs: ://user:password@ -> ://user:[REDACTED]@
  text = text.replace(/(:[/][/][^:]+:)([^@]+)(@)/g, (_, prefix, password, suffix) => {
    const structure = describeStructure(password);
    return `${prefix}[REDACTED:GIT_CREDENTIAL:${structure}]${suffix}`;
  });

  // Docker config auth: "auth": "base64" -> "auth": "[REDACTED]"
  text = text.replace(/("auth":\s*")([A-Za-z0-9+/=]{20,})(")/g, (_, prefix, auth, suffix) => {
    const structure = describeStructure(auth);
    return `${prefix}[REDACTED:DOCKER_AUTH:${structure}]${suffix}`;
  });

  return text;
}

// Redact a single line
function redactLine(line, secrets) {
  if (filterConfig.values) {
    line = redactEnvValues(line, secrets);
  }
  if (filterConfig.patterns) {
    line = redactPatterns(line);
  }
  return line;
}

// Flush buffer with redaction
function flushBufferRedacted(buffer, secrets, writer) {
  for (const line of buffer) {
    writer.write(redactLine(line, secrets));
  }
}

// Read lines from stdin
async function* readLines(stdin) {
  const decoder = new TextDecoder();
  let buffer = '';

  for await (const chunk of stdin.stream()) {
    buffer += decoder.decode(chunk, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    for (const line of lines) {
      yield line + '\n';
    }
  }

  // Final chunk
  if (buffer.length > 0) {
    yield buffer;
  }
}

// Main
async function main() {
  // Only load secrets if values filter is enabled
  const secrets = filterConfig.values ? loadSecrets() : new Map();
  let state = STATE_NORMAL;
  let buffer: string[] = [];

  const writer = Bun.stdout.writer();

  for await (const line of readLines(Bun.stdin)) {
    // Binary detection: null byte means binary data
    if (line.includes('\0')) {
      flushBufferRedacted(buffer, secrets, writer);
      buffer = [];
      writer.write(line);
      // Passthrough rest
      for await (const rest of readLines(Bun.stdin)) {
        writer.write(rest);
      }
      await writer.flush();
      return;
    }

    // Private key state machine only active when patterns filter is enabled
    if (state === STATE_NORMAL) {
      if (filterConfig.patterns && PRIVATE_KEY_BEGIN.test(line)) {
        state = STATE_IN_PRIVATE_KEY;
        buffer = [line];
      } else {
        writer.write(redactLine(line, secrets));
      }
    } else {
      buffer.push(line);

      if (PRIVATE_KEY_END.test(line)) {
        writer.write('[REDACTED:PRIVATE_KEY:multiline]\n');
        buffer = [];
        state = STATE_NORMAL;
      } else if (buffer.length > MAX_PRIVATE_KEY_BUFFER) {
        flushBufferRedacted(buffer, secrets, writer);
        buffer = [];
        state = STATE_NORMAL;
      }
    }
  }

  // EOF: flush remaining buffer
  if (buffer.length > 0) {
    flushBufferRedacted(buffer, secrets, writer);
  }

  await writer.flush();
}

await main();

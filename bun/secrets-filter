#!/usr/bin/env bun
// secrets-filter: Filter stdin for secrets, redact with labels
// Streaming mode with state machine for private keys
// Binary detection triggers passthrough
//
// Filter modes:
//   --filter=values    - redact known secret values from environment
//   --filter=patterns  - redact regex patterns (token formats)
//   --filter=all       - shorthand for both (default)
//
// Environment variables (override with --filter):
//   SECRETS_FILTER_VALUES=0|false|no    - disable values filter
//   SECRETS_FILTER_PATTERNS=0|false|no  - disable patterns filter

import { existsSync } from 'fs';
import { dirname, join } from 'path';

// Auto-regenerate patterns if missing (must complete before dynamic import)
const scriptDir = dirname(Bun.main);
const patternsGenPath = join(scriptDir, 'patterns_gen.ts');
if (!existsSync(patternsGenPath)) {
  const proc = Bun.spawn(['bun', join(scriptDir, 'generate.ts')], {
    stdout: 'inherit',
    stderr: 'inherit',
  });
  await proc.exited;
}

// Dynamic import to allow regeneration to complete first
const {
  PATTERNS,
  CONTEXT_PATTERNS,
  SPECIAL_PATTERNS,
  PRIVATE_KEY_BEGIN,
  PRIVATE_KEY_END,
  EXPLICIT_ENV_VARS,
  ENV_SUFFIXES,
  LONG_THRESHOLD,
  MAX_PRIVATE_KEY_BUFFER,
} = await import('./patterns_gen');

const STATE_NORMAL = 0;
const STATE_IN_PRIVATE_KEY = 1;

// Valid filter names
const VALID_FILTERS = new Set(['values', 'patterns', 'all']);
const FALSY_VALUES = ['0', 'false', 'no'];

// Parse filter configuration from CLI args and environment
function parseFilterConfig(): { values: boolean; patterns: boolean } {
  // Check CLI args first (--filter=X or -f X)
  const args = Bun.argv.slice(2);
  let cliFilters: string | null = null;

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('--filter=')) {
      cliFilters = arg.slice('--filter='.length);
      break;
    } else if (arg === '--filter' || arg === '-f') {
      if (i + 1 < args.length) {
        cliFilters = args[i + 1];
        break;
      }
    } else if (arg.startsWith('-f')) {
      // -fvalues style
      cliFilters = arg.slice(2);
      break;
    }
  }

  // If CLI specified, parse and use it (overrides ENV entirely)
  if (cliFilters !== null) {
    const parts = cliFilters.split(',').map(s => s.trim().toLowerCase()).filter(s => s.length > 0);
    const valid: string[] = [];
    const invalid: string[] = [];

    for (const part of parts) {
      if (VALID_FILTERS.has(part)) {
        valid.push(part);
      } else {
        invalid.push(part);
      }
    }

    // Warn about invalid filters
    for (const name of invalid) {
      console.error(`secrets-filter: unknown filter '${name}', ignoring`);
    }

    // Error if no valid filters
    if (valid.length === 0) {
      console.error('secrets-filter: no valid filters specified');
      process.exit(1);
    }

    // Determine enabled filters
    const hasAll = valid.includes('all');
    return {
      values: hasAll || valid.includes('values'),
      patterns: hasAll || valid.includes('patterns'),
    };
  }

  // No CLI args: check environment variables
  const valuesEnv = Bun.env.SECRETS_FILTER_VALUES;
  const patternsEnv = Bun.env.SECRETS_FILTER_PATTERNS;

  return {
    values: valuesEnv === undefined || !FALSY_VALUES.includes(valuesEnv.toLowerCase()),
    patterns: patternsEnv === undefined || !FALSY_VALUES.includes(patternsEnv.toLowerCase()),
  };
}

// Parse config at startup
const filterConfig = parseFilterConfig();

// Classify a segment: N=digits, A=letters, X=mixed
function classifySegment(s) {
  if (!s || s.length === 0) return '';
  if (/^\d+$/.test(s)) return `${s.length}N`;
  if (/^[A-Za-z]+$/.test(s)) return `${s.length}A`;
  return `${s.length}X`;
}

// Describe token structure for redaction label
function describeStructure(s) {
  if (!s) return '';

  // Very long tokens: show length (with prefix hint if available)
  if (s.length >= LONG_THRESHOLD) {
    for (const sep of ['-', '_', '.']) {
      if (s.includes(sep)) {
        const parts = s.split(sep);
        const first = parts[0];
        if (/^[a-zA-Z]+$/.test(first) || ['ghp', 'gho', 'ghs', 'ghr', 'npm', 'sk'].includes(first)) {
          return `${first}${sep}...:${s.length}chars`;
        }
      }
    }
    return `${s.length}chars`;
  }

  // Check for structured tokens
  for (const sep of ['-', '.', '_']) {
    if (s.includes(sep)) {
      const parts = s.split(sep);
      if (parts.length >= 2) {
        const first = parts[0];
        if (/^[A-Za-z]+$/.test(first) && first.length <= 12) {
          const segments = parts.slice(1).map(classifySegment);
          return `${first}${sep}${segments.join(sep)}`;
        }
        return parts.map(classifySegment).join(sep);
      }
    }
  }

  return classifySegment(s);
}

// Load secrets from environment variables
function loadSecrets() {
  const secrets = new Map();

  const env = Bun.env;
  for (const [name, value] of Object.entries(env)) {
    if (!value || value.length < 8) continue;

    if (EXPLICIT_ENV_VARS.has(name) || ENV_SUFFIXES.some(s => name.endsWith(s))) {
      secrets.set(name, value);
    }
  }

  return secrets;
}

// Replace known secret values with [REDACTED:VAR_NAME:structure]
function redactEnvValues(text, secrets) {
  if (secrets.size === 0) return text;

  // Sort by value length descending
  const sorted = [...secrets.entries()].sort((a, b) => b[1].length - a[1].length);

  for (const [varName, val] of sorted) {
    if (!val) continue;
    const structure = describeStructure(val);
    const replacement = `[REDACTED:${varName}:${structure}]`;
    text = text.split(val).join(replacement);
  }

  return text;
}

// Replace known token patterns
function redactPatterns(text) {
  // Direct patterns (tokens with distinctive prefixes)
  for (const [pattern, label] of PATTERNS) {
    // Reset regex lastIndex for global patterns
    pattern.lastIndex = 0;
    text = text.replace(pattern, (matched) => {
      const structure = describeStructure(matched);
      return `[REDACTED:${label}:${structure}]`;
    });
  }

  // Context patterns (lookbehind patterns for key=value, key: value, etc.)
  for (const [pattern, label] of CONTEXT_PATTERNS) {
    pattern.lastIndex = 0;
    text = text.replace(pattern, (matched) => {
      const structure = describeStructure(matched);
      return `[REDACTED:${label}:${structure}]`;
    });
  }

  // Special patterns (capture group patterns requiring custom replacement)
  for (const sp of Object.values(SPECIAL_PATTERNS)) {
    sp.pattern.lastIndex = 0;
    text = text.replace(sp.pattern, (...args) => {
      // args: [fullMatch, group1, group2, ..., offset, string]
      const secret = args[sp.secretGroup];
      const structure = describeStructure(secret);
      // Reconstruct with all groups, replacing only the secret group
      const groups = args.slice(1, -2); // exclude offset and string
      groups[sp.secretGroup - 1] = `[REDACTED:${sp.label}:${structure}]`;
      return groups.join('');
    });
  }

  return text;
}

// Redact a single line
function redactLine(line, secrets) {
  if (filterConfig.values) {
    line = redactEnvValues(line, secrets);
  }
  if (filterConfig.patterns) {
    line = redactPatterns(line);
  }
  return line;
}

// Flush buffer with redaction
function flushBufferRedacted(buffer, secrets, writer) {
  for (const line of buffer) {
    writer.write(redactLine(line, secrets));
  }
}

// Read lines from stdin
async function* readLines(stdin) {
  const decoder = new TextDecoder();
  let buffer = '';

  for await (const chunk of stdin.stream()) {
    buffer += decoder.decode(chunk, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    for (const line of lines) {
      yield line + '\n';
    }
  }

  // Final chunk
  if (buffer.length > 0) {
    yield buffer;
  }
}

// Main
async function main() {
  // Only load secrets if values filter is enabled
  const secrets = filterConfig.values ? loadSecrets() : new Map();
  let state = STATE_NORMAL;
  let buffer: string[] = [];

  const writer = Bun.stdout.writer();

  for await (const line of readLines(Bun.stdin)) {
    // Binary detection: null byte means binary data
    if (line.includes('\0')) {
      flushBufferRedacted(buffer, secrets, writer);
      buffer = [];
      writer.write(line);
      // Passthrough rest
      for await (const rest of readLines(Bun.stdin)) {
        writer.write(rest);
      }
      await writer.flush();
      return;
    }

    // Private key state machine only active when patterns filter is enabled
    if (state === STATE_NORMAL) {
      if (filterConfig.patterns && PRIVATE_KEY_BEGIN.test(line)) {
        state = STATE_IN_PRIVATE_KEY;
        buffer = [line];
      } else {
        writer.write(redactLine(line, secrets));
      }
    } else {
      buffer.push(line);

      if (PRIVATE_KEY_END.test(line)) {
        writer.write('[REDACTED:PRIVATE_KEY:multiline]\n');
        buffer = [];
        state = STATE_NORMAL;
      } else if (buffer.length > MAX_PRIVATE_KEY_BUFFER) {
        flushBufferRedacted(buffer, secrets, writer);
        buffer = [];
        state = STATE_NORMAL;
      }
    }
  }

  // EOF: flush remaining buffer
  if (buffer.length > 0) {
    flushBufferRedacted(buffer, secrets, writer);
  }

  await writer.flush();
}

await main();

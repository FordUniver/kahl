#!/usr/bin/env bun
// Generate patterns_gen.ts from YAML pattern definitions
// Usage: bun run generate.ts

import { $ } from "bun";
import { readFileSync, writeFileSync } from "fs";
import { createHash } from "crypto";
import { dirname, join } from "path";

const SCRIPT_DIR = dirname(Bun.main);
const REPO_ROOT = join(SCRIPT_DIR, "..");
const PATTERNS_YAML = join(REPO_ROOT, "patterns/patterns.yaml");
const ENV_YAML = join(REPO_ROOT, "patterns/env.yaml");
const ENTROPY_YAML = join(REPO_ROOT, "patterns/entropy.yaml");
const OUTPUT_FILE = join(SCRIPT_DIR, "patterns_gen.ts");

interface DirectPattern {
  pattern: string;
  label: string;
  multiline?: boolean;
}

interface ContextPattern {
  prefix: string;
  value: string;
  label: string;
}

interface SpecialPattern {
  pattern: string;
  label: string;
  secret_group: number;
}

interface PatternsYaml {
  version: number;
  constants: {
    long_threshold: number;
    max_private_key_buffer: number;
  };
  patterns: DirectPattern[];
  context_patterns: ContextPattern[];
  special_patterns: Record<string, SpecialPattern>;
  private_key: {
    begin: string;
    end: string;
  };
}

interface EnvYaml {
  explicit: string[];
  suffixes: string[];
}

interface EntropyExclusion {
  pattern: string;
  label: string;
  case_insensitive?: boolean;
  context_keywords?: string[];
}

interface EntropyYaml {
  enabled_by_default: boolean;
  thresholds: {
    hex: number;
    base64: number;
    alphanumeric: number;
  };
  token_length: {
    min: number;
    max: number;
  };
  exclusions: EntropyExclusion[];
  context_keywords: string[];
}

// Parse YAML using yq (more reliable than built-in parsing)
async function parseYaml<T>(path: string): Promise<T> {
  const result = await $`yq -o=json ${path}`.text();
  return JSON.parse(result) as T;
}

// Compute SHA256 hash of file contents
function hashFile(path: string): string {
  const content = readFileSync(path);
  return createHash("sha256").update(content).digest("hex").slice(0, 12);
}

// Compute combined hash of all source files
function computeSourceHash(): string {
  const hasher = createHash("sha256");
  for (const path of [PATTERNS_YAML, ENV_YAML, ENTROPY_YAML]) {
    try {
      hasher.update(readFileSync(path));
    } catch {
      // File may not exist (entropy.yaml is optional)
    }
  }
  return hasher.digest("hex").slice(0, 12);
}

// Check if entropy.yaml exists
function entropyYamlExists(): boolean {
  try {
    readFileSync(ENTROPY_YAML);
    return true;
  } catch {
    return false;
  }
}

// Escape string for use in TypeScript source
function escapeString(s: string): string {
  return s
    .replace(/\\/g, "\\\\")
    .replace(/'/g, "\\'")
    .replace(/\n/g, "\\n");
}

// Escape pattern for use in regex literal (escape forward slashes)
function escapeRegexLiteral(pattern: string): string {
  return pattern.replace(/\//g, "\\/");
}

// Generate TypeScript source code
async function generate(): Promise<string> {
  const patterns = await parseYaml<PatternsYaml>(PATTERNS_YAML);
  const env = await parseYaml<EnvYaml>(ENV_YAML);

  // Load entropy config if available
  let entropy: EntropyYaml | null = null;
  if (entropyYamlExists()) {
    entropy = await parseYaml<EntropyYaml>(ENTROPY_YAML);
  }

  const sourceHash = computeSourceHash();
  const timestamp = new Date().toISOString();

  const lines: string[] = [];

  // Header
  lines.push("// Generated by generate.ts - DO NOT EDIT");
  lines.push(`// Generated: ${timestamp}`);
  lines.push(`// Source hash: ${sourceHash}`);
  lines.push("");

  // Constants
  lines.push(`export const LONG_THRESHOLD = ${patterns.constants.long_threshold};`);
  lines.push(`export const MAX_PRIVATE_KEY_BUFFER = ${patterns.constants.max_private_key_buffer};`);
  lines.push("");

  // Private key markers
  lines.push(`export const PRIVATE_KEY_BEGIN = /${escapeRegexLiteral(patterns.private_key.begin)}/;`);
  lines.push(`export const PRIVATE_KEY_END = /${escapeRegexLiteral(patterns.private_key.end)}/;`);
  lines.push("");

  // Direct patterns (excluding multiline private key pattern)
  lines.push("export const PATTERNS: [RegExp, string][] = [");
  for (const p of patterns.patterns) {
    if (p.multiline) continue; // Skip multiline patterns, handled separately
    lines.push(`  [/${escapeRegexLiteral(p.pattern)}/g, '${p.label}'],`);
  }
  lines.push("];");
  lines.push("");

  // Context patterns (using lookbehind)
  lines.push("export const CONTEXT_PATTERNS: [RegExp, string][] = [");
  for (const cp of patterns.context_patterns) {
    // JavaScript uses lookbehind: (?<=prefix)value
    const escapedPrefix = escapeRegexLiteral(escapeString(cp.prefix));
    const escapedValue = escapeRegexLiteral(cp.value);
    lines.push(`  [/(?<=${escapedPrefix})${escapedValue}/g, '${cp.label}'],`);
  }
  lines.push("];");
  lines.push("");

  // Special patterns
  lines.push("export interface SpecialPatternInfo {");
  lines.push("  pattern: RegExp;");
  lines.push("  label: string;");
  lines.push("  secretGroup: number;");
  lines.push("}");
  lines.push("");
  lines.push("export const SPECIAL_PATTERNS: Record<string, SpecialPatternInfo> = {");
  for (const [name, sp] of Object.entries(patterns.special_patterns)) {
    lines.push(`  ${name}: {`);
    lines.push(`    pattern: /${escapeRegexLiteral(sp.pattern)}/g,`);
    lines.push(`    label: '${sp.label}',`);
    lines.push(`    secretGroup: ${sp.secret_group},`);
    lines.push("  },");
  }
  lines.push("};");
  lines.push("");

  // Multiline private key pattern (for batch mode)
  const multilinePattern = patterns.patterns.find(p => p.multiline);
  if (multilinePattern) {
    lines.push("// Multiline pattern for batch mode fallback");
    lines.push(`export const PRIVATE_KEY_MULTILINE: [RegExp, string] = [/${escapeRegexLiteral(multilinePattern.pattern)}/g, '${multilinePattern.label}'];`);
    lines.push("");
  }

  // Environment variable detection
  lines.push("export const EXPLICIT_ENV_VARS = new Set([");
  for (const v of env.explicit) {
    lines.push(`  '${v}',`);
  }
  lines.push("]);");
  lines.push("");

  lines.push("export const ENV_SUFFIXES: string[] = [");
  for (const s of env.suffixes) {
    lines.push(`  '${s}',`);
  }
  lines.push("];");
  lines.push("");

  // Entropy detection configuration
  lines.push("// Entropy detection configuration");
  if (entropy) {
    lines.push(`export const ENTROPY_ENABLED_DEFAULT = ${entropy.enabled_by_default};`);
    lines.push("");
    lines.push("export const ENTROPY_THRESHOLDS: Record<string, number> = {");
    lines.push(`  hex: ${entropy.thresholds.hex},`);
    lines.push(`  base64: ${entropy.thresholds.base64},`);
    lines.push(`  alphanumeric: ${entropy.thresholds.alphanumeric},`);
    lines.push("};");
    lines.push("");
    lines.push(`export const ENTROPY_MIN_LENGTH = ${entropy.token_length.min};`);
    lines.push(`export const ENTROPY_MAX_LENGTH = ${entropy.token_length.max};`);
    lines.push("");

    // Exclusion interface and array
    lines.push("export interface EntropyExclusion {");
    lines.push("  pattern: string;");
    lines.push("  label: string;");
    lines.push("  caseInsensitive: boolean;");
    lines.push("  contextKeywords: string[] | null;");
    lines.push("}");
    lines.push("");
    lines.push("export const ENTROPY_EXCLUSIONS: EntropyExclusion[] = [");
    for (const excl of entropy.exclusions) {
      const kw = excl.context_keywords ? JSON.stringify(excl.context_keywords) : "null";
      lines.push("  {");
      lines.push(`    pattern: '${escapeString(excl.pattern)}',`);
      lines.push(`    label: '${excl.label}',`);
      lines.push(`    caseInsensitive: ${excl.case_insensitive ?? false},`);
      lines.push(`    contextKeywords: ${kw},`);
      lines.push("  },");
    }
    lines.push("];");
    lines.push("");

    // Context keywords set
    lines.push("export const ENTROPY_CONTEXT_KEYWORDS = new Set([");
    for (const kw of entropy.context_keywords) {
      lines.push(`  '${kw}',`);
    }
    lines.push("]);");
  } else {
    // Defaults when entropy.yaml is not found
    lines.push("export const ENTROPY_ENABLED_DEFAULT = false;");
    lines.push("export const ENTROPY_THRESHOLDS: Record<string, number> = { hex: 3.0, base64: 4.5, alphanumeric: 4.5 };");
    lines.push("export const ENTROPY_MIN_LENGTH = 16;");
    lines.push("export const ENTROPY_MAX_LENGTH = 256;");
    lines.push("");
    lines.push("export interface EntropyExclusion {");
    lines.push("  pattern: string;");
    lines.push("  label: string;");
    lines.push("  caseInsensitive: boolean;");
    lines.push("  contextKeywords: string[] | null;");
    lines.push("}");
    lines.push("");
    lines.push("export const ENTROPY_EXCLUSIONS: EntropyExclusion[] = [];");
    lines.push("export const ENTROPY_CONTEXT_KEYWORDS = new Set<string>();");
  }
  lines.push("");

  return lines.join("\n");
}

// Main
async function main() {
  try {
    const source = await generate();
    writeFileSync(OUTPUT_FILE, source);
    console.log(`Generated ${OUTPUT_FILE}`);
  } catch (err) {
    console.error("Error generating patterns:", err);
    process.exit(1);
  }
}

await main();

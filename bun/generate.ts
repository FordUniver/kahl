#!/usr/bin/env bun
// Generate patterns_gen.ts from YAML pattern definitions
// Usage: bun run generate.ts

import { $ } from "bun";
import { readFileSync, writeFileSync } from "fs";
import { createHash } from "crypto";
import { dirname, join } from "path";

const SCRIPT_DIR = dirname(Bun.main);
const REPO_ROOT = join(SCRIPT_DIR, "..");
const PATTERNS_YAML = join(REPO_ROOT, "patterns/patterns.yaml");
const ENV_YAML = join(REPO_ROOT, "patterns/env.yaml");
const OUTPUT_FILE = join(SCRIPT_DIR, "patterns_gen.ts");

interface DirectPattern {
  pattern: string;
  label: string;
  multiline?: boolean;
}

interface ContextPattern {
  prefix: string;
  value: string;
  label: string;
}

interface SpecialPattern {
  pattern: string;
  label: string;
  secret_group: number;
}

interface PatternsYaml {
  version: number;
  constants: {
    long_threshold: number;
    max_private_key_buffer: number;
  };
  patterns: DirectPattern[];
  context_patterns: ContextPattern[];
  special_patterns: Record<string, SpecialPattern>;
  private_key: {
    begin: string;
    end: string;
  };
}

interface EnvYaml {
  explicit: string[];
  suffixes: string[];
}

// Parse YAML using yq (more reliable than built-in parsing)
async function parseYaml<T>(path: string): Promise<T> {
  const result = await $`yq -o=json ${path}`.text();
  return JSON.parse(result) as T;
}

// Compute SHA256 hash of file contents
function hashFile(path: string): string {
  const content = readFileSync(path);
  return createHash("sha256").update(content).digest("hex").slice(0, 12);
}

// Escape string for use in TypeScript source
function escapeString(s: string): string {
  return s
    .replace(/\\/g, "\\\\")
    .replace(/'/g, "\\'")
    .replace(/\n/g, "\\n");
}

// Escape pattern for use in regex literal (escape forward slashes)
function escapeRegexLiteral(pattern: string): string {
  return pattern.replace(/\//g, "\\/");
}

// Generate TypeScript source code
async function generate(): Promise<string> {
  const patterns = await parseYaml<PatternsYaml>(PATTERNS_YAML);
  const env = await parseYaml<EnvYaml>(ENV_YAML);

  const patternsHash = hashFile(PATTERNS_YAML);
  const envHash = hashFile(ENV_YAML);
  const timestamp = new Date().toISOString();

  const lines: string[] = [];

  // Header
  lines.push("// Generated by generate.ts - DO NOT EDIT");
  lines.push(`// Generated: ${timestamp}`);
  lines.push(`// Source: patterns/patterns.yaml (${patternsHash}), patterns/env.yaml (${envHash})`);
  lines.push("");

  // Constants
  lines.push(`export const LONG_THRESHOLD = ${patterns.constants.long_threshold};`);
  lines.push(`export const MAX_PRIVATE_KEY_BUFFER = ${patterns.constants.max_private_key_buffer};`);
  lines.push("");

  // Private key markers
  lines.push(`export const PRIVATE_KEY_BEGIN = /${escapeRegexLiteral(patterns.private_key.begin)}/;`);
  lines.push(`export const PRIVATE_KEY_END = /${escapeRegexLiteral(patterns.private_key.end)}/;`);
  lines.push("");

  // Direct patterns (excluding multiline private key pattern)
  lines.push("export const PATTERNS: [RegExp, string][] = [");
  for (const p of patterns.patterns) {
    if (p.multiline) continue; // Skip multiline patterns, handled separately
    lines.push(`  [/${escapeRegexLiteral(p.pattern)}/g, '${p.label}'],`);
  }
  lines.push("];");
  lines.push("");

  // Context patterns (using lookbehind)
  lines.push("export const CONTEXT_PATTERNS: [RegExp, string][] = [");
  for (const cp of patterns.context_patterns) {
    // JavaScript uses lookbehind: (?<=prefix)value
    const escapedPrefix = escapeRegexLiteral(escapeString(cp.prefix));
    const escapedValue = escapeRegexLiteral(cp.value);
    lines.push(`  [/(?<=${escapedPrefix})${escapedValue}/g, '${cp.label}'],`);
  }
  lines.push("];");
  lines.push("");

  // Special patterns
  lines.push("export interface SpecialPatternInfo {");
  lines.push("  pattern: RegExp;");
  lines.push("  label: string;");
  lines.push("  secretGroup: number;");
  lines.push("}");
  lines.push("");
  lines.push("export const SPECIAL_PATTERNS: Record<string, SpecialPatternInfo> = {");
  for (const [name, sp] of Object.entries(patterns.special_patterns)) {
    lines.push(`  ${name}: {`);
    lines.push(`    pattern: /${escapeRegexLiteral(sp.pattern)}/g,`);
    lines.push(`    label: '${sp.label}',`);
    lines.push(`    secretGroup: ${sp.secret_group},`);
    lines.push("  },");
  }
  lines.push("};");
  lines.push("");

  // Multiline private key pattern (for batch mode)
  const multilinePattern = patterns.patterns.find(p => p.multiline);
  if (multilinePattern) {
    lines.push("// Multiline pattern for batch mode fallback");
    lines.push(`export const PRIVATE_KEY_MULTILINE: [RegExp, string] = [/${escapeRegexLiteral(multilinePattern.pattern)}/g, '${multilinePattern.label}'];`);
    lines.push("");
  }

  // Environment variable detection
  lines.push("export const EXPLICIT_ENV_VARS = new Set([");
  for (const v of env.explicit) {
    lines.push(`  '${v}',`);
  }
  lines.push("]);");
  lines.push("");

  lines.push("export const ENV_SUFFIXES: string[] = [");
  for (const s of env.suffixes) {
    lines.push(`  '${s}',`);
  }
  lines.push("];");
  lines.push("");

  return lines.join("\n");
}

// Main
async function main() {
  try {
    const source = await generate();
    writeFileSync(OUTPUT_FILE, source);
    console.log(`Generated ${OUTPUT_FILE}`);
  } catch (err) {
    console.error("Error generating patterns:", err);
    process.exit(1);
  }
}

await main();

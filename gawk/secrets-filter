#!/usr/bin/env gawk -f
# secrets-filter: Filter stdin for secrets, redact with labels
# Streaming mode with state machine for private keys
# Uses gawk (GNU AWK) for gensub() and ENVIRON support
#
# Filter modes:
#   --filter=values    - redact known secret values from environment
#   --filter=patterns  - redact regex patterns (token formats)
#   --filter=all       - shorthand for both (default)
#
# Environment variables (override with --filter):
#   SECRETS_FILTER_VALUES=0|false|no    - disable values filter
#   SECRETS_FILTER_PATTERNS=0|false|no  - disable patterns filter

BEGIN {
    # Constants
    STATE_NORMAL = 0
    STATE_IN_PRIVATE_KEY = 1
    MAX_PRIVATE_KEY_BUFFER = 100
    LONG_THRESHOLD = 50

    # State
    state = STATE_NORMAL
    buffer_len = 0

    # Separators for structure description (order matters: -, ., _ like Python)
    SEPS[1] = "-"
    SEPS[2] = "."
    SEPS[3] = "_"

    # Parse filter configuration from CLI args and environment
    parse_filter_config()

    # Load secrets from environment (if values filter enabled)
    if (filter_values) {
        load_secrets()
    }
}

# Binary detection: null byte triggers passthrough
/\x00/ {
    flush_buffer()
    print
    while ((getline) > 0) print
    exit
}

# Main processing loop
{
    if (state == STATE_NORMAL) {
        if (filter_patterns && /-----BEGIN [A-Z ]*PRIVATE KEY-----/) {
            state = STATE_IN_PRIVATE_KEY
            buffer[++buffer_len] = $0
        } else {
            printf "%s\n", redact_line($0)
            fflush()
        }
    } else {
        buffer[++buffer_len] = $0

        if (/-----END [A-Z ]*PRIVATE KEY-----/) {
            print "[REDACTED:PRIVATE_KEY:multiline]"
            fflush()
            delete buffer
            buffer_len = 0
            state = STATE_NORMAL
        } else if (buffer_len > MAX_PRIVATE_KEY_BUFFER) {
            flush_buffer()
            state = STATE_NORMAL
        }
    }
}

END {
    if (buffer_len > 0) flush_buffer()
}

# Check if a value is falsy (0, false, no - case insensitive)
function is_falsy(val) {
    return tolower(val) ~ /^(0|false|no)$/
}

# Parse filter configuration from CLI args and environment
function parse_filter_config(    i, arg, filter_arg, parts, nparts, j, filter, valid_found, invalid_count, invalid_filters) {
    # Default: both filters enabled
    filter_values = 1
    filter_patterns = 1

    # Check for --filter or -f in ARGV
    filter_arg = ""
    for (i = 1; i < ARGC; i++) {
        arg = ARGV[i]
        if (arg ~ /^--filter=/) {
            filter_arg = substr(arg, 10)  # length("--filter=") + 1
            delete ARGV[i]
            break
        } else if (arg ~ /^-f=/) {
            filter_arg = substr(arg, 4)  # length("-f=") + 1
            delete ARGV[i]
            break
        } else if (arg == "--filter" || arg == "-f") {
            if (i + 1 < ARGC) {
                filter_arg = ARGV[i + 1]
                delete ARGV[i]
                delete ARGV[i + 1]
                break
            }
        }
    }

    if (filter_arg != "") {
        # CLI flag overrides environment entirely
        filter_values = 0
        filter_patterns = 0

        valid_found = 0
        invalid_count = 0

        nparts = split(filter_arg, parts, ",")
        for (j = 1; j <= nparts; j++) {
            # Trim whitespace and lowercase
            filter = tolower(parts[j])
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", filter)

            if (filter == "values") {
                filter_values = 1
                valid_found = 1
            } else if (filter == "patterns") {
                filter_patterns = 1
                valid_found = 1
            } else if (filter == "all") {
                filter_values = 1
                filter_patterns = 1
                valid_found = 1
            } else if (filter != "") {
                # Collect invalid filter for warning
                invalid_filters[++invalid_count] = parts[j]
            }
        }

        # Warn about invalid filters
        for (j = 1; j <= invalid_count; j++) {
            # Trim whitespace for display
            filter = invalid_filters[j]
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", filter)
            printf "secrets-filter: unknown filter '%s', ignoring\n", filter > "/dev/stderr"
        }

        # Error if no valid filters found
        if (!valid_found) {
            print "secrets-filter: no valid filters specified" > "/dev/stderr"
            exit 1
        }
    } else {
        # Check environment variables
        if ("SECRETS_FILTER_VALUES" in ENVIRON && is_falsy(ENVIRON["SECRETS_FILTER_VALUES"])) {
            filter_values = 0
        }
        if ("SECRETS_FILTER_PATTERNS" in ENVIRON && is_falsy(ENVIRON["SECRETS_FILTER_PATTERNS"])) {
            filter_patterns = 0
        }
    }
}

# Load secrets from environment variables
function load_secrets(    explicit_vars, n, i, name, value) {
    # Explicit list of known secret variable names
    explicit_vars = "GITHUB_TOKEN GH_TOKEN GITLAB_TOKEN GLAB_TOKEN BITBUCKET_TOKEN " \
                    "AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AZURE_CLIENT_SECRET " \
                    "OPENAI_API_KEY ANTHROPIC_API_KEY CLAUDE_API_KEY " \
                    "SLACK_TOKEN SLACK_BOT_TOKEN SLACK_WEBHOOK_URL " \
                    "NPM_TOKEN PYPI_TOKEN DOCKER_PASSWORD " \
                    "DATABASE_URL REDIS_URL MONGODB_URI " \
                    "JWT_SECRET SESSION_SECRET ENCRYPTION_KEY " \
                    "SENDGRID_API_KEY TWILIO_AUTH_TOKEN STRIPE_SECRET_KEY"

    # Check explicit variable names
    n = split(explicit_vars, explicit_arr)
    for (i = 1; i <= n; i++) {
        name = explicit_arr[i]
        if (name in ENVIRON) {
            value = ENVIRON[name]
            if (length(value) >= 8) {
                secrets[name] = value
                secrets_order[++secrets_count] = name
            }
        }
    }

    # Pattern match ALL env vars - include any var whose name ends with secret-like suffixes
    for (name in ENVIRON) {
        # Skip if already added from explicit list
        if (name in secrets) continue

        value = ENVIRON[name]
        if (length(value) < 8) continue

        if (name ~ /(_SECRET|_PASSWORD|_TOKEN|_API_KEY|_PRIVATE_KEY|_AUTH|_CREDENTIAL)$/) {
            secrets[name] = value
            secrets_order[++secrets_count] = name
        }
    }

    # Sort by value length descending (for longest-first replacement)
    sort_secrets_by_length()
}

# Sort secrets by value length (descending) using insertion sort
function sort_secrets_by_length(    i, j, key, len_i, len_j) {
    for (i = 2; i <= secrets_count; i++) {
        key = secrets_order[i]
        j = i - 1
        while (j > 0) {
            len_i = length(secrets[key])
            len_j = length(secrets[secrets_order[j]])
            if (len_j >= len_i) break
            secrets_order[j + 1] = secrets_order[j]
            j--
        }
        secrets_order[j + 1] = key
    }
}

# Classify segment: N=digits, A=letters, X=mixed
function classify_segment(s,    len) {
    if (s == "") return ""
    len = length(s)
    if (s ~ /^[0-9]+$/) return len "N"
    if (s ~ /^[A-Za-z]+$/) return len "A"
    return len "X"
}

# Describe token structure for redaction label
function describe_structure(s,    len, si, sep, n, parts, first, i, result) {
    if (s == "") return ""
    len = length(s)

    # Very long tokens: show length with prefix hint
    if (len >= LONG_THRESHOLD) {
        for (si = 1; si <= 3; si++) {
            sep = SEPS[si]
            if (index(s, sep) > 0) {
                n = split(s, parts, sep)
                first = parts[1]
                if (first ~ /^[A-Za-z]+$/ || first ~ /^(ghp|gho|ghs|ghr|npm|sk)$/) {
                    return first sep "...:" len "chars"
                }
            }
        }
        return len "chars"
    }

    # Check for structured tokens
    for (si = 1; si <= 3; si++) {
        sep = SEPS[si]
        if (index(s, sep) > 0) {
            n = split(s, parts, sep)
            if (n >= 2) {
                first = parts[1]
                if (first ~ /^[A-Za-z]+$/ && length(first) <= 12) {
                    result = first sep
                    for (i = 2; i <= n; i++) {
                        if (i > 2) result = result sep
                        result = result classify_segment(parts[i])
                    }
                    return result
                }
                result = classify_segment(parts[1])
                for (i = 2; i <= n; i++) {
                    result = result sep classify_segment(parts[i])
                }
                return result
            }
        }
    }

    return classify_segment(s)
}

# Redact known env values
function redact_env_values(line,    i, var, val, structure, replacement, escaped) {
    for (i = 1; i <= secrets_count; i++) {
        var = secrets_order[i]
        val = secrets[var]
        if (val == "") continue
        if (index(line, val) == 0) continue

        structure = describe_structure(val)
        replacement = "[REDACTED:" var ":" structure "]"
        # Escape special regex chars in val
        escaped = val
        gsub(/[[\\.^$*+?{}|()]/, "\\\\&", escaped)
        gsub(escaped, replacement, line)
    }
    return line
}

# Redact known token patterns
function redact_patterns(line,    structure, matched, pos, len, arr, prefix, suffix) {
    # GitHub - fixed length patterns (need dynamic structure for content classification)
    while (match(line, /ghp_[A-Za-z0-9]{36}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:GITHUB_PAT:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /gho_[A-Za-z0-9]{36}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:GITHUB_OAUTH:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /ghs_[A-Za-z0-9]{36}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:GITHUB_SERVER:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /ghr_[A-Za-z0-9]{36}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:GITHUB_REFRESH:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # GitHub - variable length (need dynamic structure)
    while (match(line, /github_pat_[A-Za-z0-9_]{22,}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:GITHUB_PAT:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # GitLab - variable length
    while (match(line, /glpat-[A-Za-z0-9_-]{20,}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:GITLAB_PAT:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # Slack - variable length
    while (match(line, /xoxb-[0-9]+-[0-9A-Za-z-]+/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:SLACK_BOT:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /xoxp-[0-9]+-[0-9A-Za-z-]+/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:SLACK_USER:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /xoxa-[0-9]+-[0-9A-Za-z-]+/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:SLACK_APP:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /xoxs-[0-9]+-[0-9A-Za-z-]+/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:SLACK_SESSION:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # OpenAI - fixed 48 char (need dynamic structure)
    while (match(line, /sk-[A-Za-z0-9]{48}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:OPENAI_KEY:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # OpenAI project / Anthropic - variable length
    while (match(line, /sk-proj-[A-Za-z0-9_-]{20,}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:OPENAI_PROJECT_KEY:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /sk-ant-[A-Za-z0-9-]{90,}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:ANTHROPIC_KEY:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # AWS - fixed length (need dynamic structure)
    while (match(line, /AKIA[A-Z0-9]{16}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:AWS_ACCESS_KEY:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # Google Cloud - fixed length (need dynamic structure)
    while (match(line, /AIza[A-Za-z0-9_-]{35}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:GOOGLE_API_KEY:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # age encryption - fixed length (need dynamic structure)
    while (match(line, /AGE-SECRET-KEY-[A-Z0-9]{59}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:AGE_SECRET_KEY:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # Stripe - variable length
    while (match(line, /sk_live_[A-Za-z0-9]{24,}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:STRIPE_SECRET:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /sk_test_[A-Za-z0-9]{24,}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:STRIPE_TEST:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /pk_live_[A-Za-z0-9]{24,}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:STRIPE_PUBLISHABLE:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # Twilio - fixed length but needs dynamic structure
    while (match(line, /SK[a-f0-9]{32}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:TWILIO_KEY:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # SendGrid - variable length (min 10 chars per segment to avoid matching structure descriptions)
    while (match(line, /SG\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:SENDGRID_KEY:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # npm - fixed length (need dynamic structure)
    while (match(line, /npm_[A-Za-z0-9]{36}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:NPM_TOKEN:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # PyPI - variable length
    while (match(line, /pypi-[A-Za-z0-9_-]{100,}/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:PYPI_TOKEN:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # JWT tokens - variable length
    while (match(line, /eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/)) {
        matched = substr(line, RSTART, RLENGTH)
        structure = describe_structure(matched)
        line = substr(line, 1, RSTART - 1) "[REDACTED:JWT_TOKEN:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # netrc/authinfo - need structure for captured value
    # Exclude [ to prevent re-matching [REDACTED:...]
    while (match(line, /(password )([^[:space:]\[]+)/, arr)) {
        structure = describe_structure(arr[2])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:NETRC_PASSWORD:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(passwd )([^[:space:]\[]+)/, arr)) {
        structure = describe_structure(arr[2])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:NETRC_PASSWORD:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # Generic key=value patterns - need structure for captured value
    while (match(line, /(password=)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:PASSWORD_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(password:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2] arr[3])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:PASSWORD_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(Password=)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:PASSWORD_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(Password:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2] arr[3])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:PASSWORD_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(secret=)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:SECRET_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(secret:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2] arr[3])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:SECRET_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(Secret=)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:SECRET_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(Secret:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2] arr[3])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:SECRET_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(token=)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:TOKEN_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(token:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2] arr[3])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:TOKEN_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(Token=)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:TOKEN_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }
    while (match(line, /(Token:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, arr)) {
        structure = describe_structure(arr[2] arr[3])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:TOKEN_VALUE:" structure "]" substr(line, RSTART + RLENGTH)
    }

    # Git credential URLs: ://user:password@ -> ://user:[REDACTED]@
    while (match(line, /(:[/][/][^:]+:)([^@\[]+)(@)/, arr)) {
        structure = describe_structure(arr[2])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:GIT_CREDENTIAL:" structure "]" arr[3] substr(line, RSTART + RLENGTH)
    }

    # Docker config auth
    while (match(line, /("auth":[[:space:]]*")([A-Za-z0-9+/=]{20,})(")/, arr)) {
        structure = describe_structure(arr[2])
        line = substr(line, 1, RSTART - 1) arr[1] "[REDACTED:DOCKER_AUTH:" structure "]" arr[3] substr(line, RSTART + RLENGTH)
    }

    return line
}

# Redact a single line based on filter configuration
function redact_line(line) {
    if (filter_values) {
        line = redact_env_values(line)
    }
    if (filter_patterns) {
        line = redact_patterns(line)
    }
    return line
}

# Flush buffer with redaction
function flush_buffer(    i) {
    for (i = 1; i <= buffer_len; i++) {
        printf "%s\n", redact_line(buffer[i])
    }
    fflush()
    delete buffer
    buffer_len = 0
}

#!/usr/bin/env gawk -f
# secrets-filter: Filter stdin for secrets, redact with labels
# Streaming mode with state machine for private keys
# Uses gawk (GNU AWK) for gensub() and ENVIRON support

BEGIN {
    # Constants
    STATE_NORMAL = 0
    STATE_IN_PRIVATE_KEY = 1
    MAX_PRIVATE_KEY_BUFFER = 100
    LONG_THRESHOLD = 50

    # State
    state = STATE_NORMAL
    buffer_len = 0

    # Separators for structure description (order matters)
    SEPS[1] = "-"
    SEPS[2] = "_"
    SEPS[3] = "."

    # Load secrets from environment
    load_secrets()
}

# Binary detection: null byte triggers passthrough
/\x00/ {
    flush_buffer()
    print
    while ((getline) > 0) print
    exit
}

# Main processing loop
{
    if (state == STATE_NORMAL) {
        if (/-----BEGIN [A-Z ]*PRIVATE KEY-----/) {
            state = STATE_IN_PRIVATE_KEY
            buffer[++buffer_len] = $0
        } else {
            printf "%s\n", redact_line($0)
            fflush()
        }
    } else {
        buffer[++buffer_len] = $0

        if (/-----END [A-Z ]*PRIVATE KEY-----/) {
            print "[REDACTED:PRIVATE_KEY:multiline]"
            fflush()
            delete buffer
            buffer_len = 0
            state = STATE_NORMAL
        } else if (buffer_len > MAX_PRIVATE_KEY_BUFFER) {
            flush_buffer()
            state = STATE_NORMAL
        }
    }
}

END {
    if (buffer_len > 0) flush_buffer()
}

# Load secrets from environment variables
function load_secrets(    explicit_vars, n, i, name, value) {
    # Explicit list of known secret variable names
    explicit_vars = "GITHUB_TOKEN GH_TOKEN GITLAB_TOKEN GLAB_TOKEN BITBUCKET_TOKEN " \
                    "AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AZURE_CLIENT_SECRET " \
                    "OPENAI_API_KEY ANTHROPIC_API_KEY CLAUDE_API_KEY " \
                    "SLACK_TOKEN SLACK_BOT_TOKEN SLACK_WEBHOOK_URL " \
                    "NPM_TOKEN PYPI_TOKEN DOCKER_PASSWORD " \
                    "DATABASE_URL REDIS_URL MONGODB_URI " \
                    "JWT_SECRET SESSION_SECRET ENCRYPTION_KEY " \
                    "SENDGRID_API_KEY TWILIO_AUTH_TOKEN STRIPE_SECRET_KEY"

    # Check explicit variable names
    n = split(explicit_vars, explicit_arr)
    for (i = 1; i <= n; i++) {
        name = explicit_arr[i]
        if (name in ENVIRON) {
            value = ENVIRON[name]
            if (length(value) >= 8) {
                secrets[name] = value
                secrets_order[++secrets_count] = name
            }
        }
    }

    # Pattern match ALL env vars - include any var whose name ends with secret-like suffixes
    for (name in ENVIRON) {
        # Skip if already added from explicit list
        if (name in secrets) continue

        value = ENVIRON[name]
        if (length(value) < 8) continue

        if (name ~ /(_SECRET|_PASSWORD|_TOKEN|_API_KEY|_PRIVATE_KEY|_AUTH|_CREDENTIAL)$/) {
            secrets[name] = value
            secrets_order[++secrets_count] = name
        }
    }

    # Sort by value length descending (for longest-first replacement)
    sort_secrets_by_length()
}

# Sort secrets by value length (descending) using insertion sort
function sort_secrets_by_length(    i, j, key, len_i, len_j) {
    for (i = 2; i <= secrets_count; i++) {
        key = secrets_order[i]
        j = i - 1
        while (j > 0) {
            len_i = length(secrets[key])
            len_j = length(secrets[secrets_order[j]])
            if (len_j >= len_i) break
            secrets_order[j + 1] = secrets_order[j]
            j--
        }
        secrets_order[j + 1] = key
    }
}

# Classify segment: N=digits, A=letters, X=mixed
function classify_segment(s,    len) {
    if (s == "") return ""
    len = length(s)
    if (s ~ /^[0-9]+$/) return len "N"
    if (s ~ /^[A-Za-z]+$/) return len "A"
    return len "X"
}

# Describe token structure for redaction label
function describe_structure(s,    len, si, sep, n, parts, first, i, result) {
    if (s == "") return ""
    len = length(s)

    # Very long tokens: show length with prefix hint
    if (len >= LONG_THRESHOLD) {
        for (si = 1; si <= 3; si++) {
            sep = SEPS[si]
            if (index(s, sep) > 0) {
                n = split(s, parts, sep)
                first = parts[1]
                if (first ~ /^[A-Za-z]+$/ || first ~ /^(ghp|gho|ghs|ghr|npm|sk)$/) {
                    return first sep "...:" len "chars"
                }
            }
        }
        return len "chars"
    }

    # Check for structured tokens
    for (si = 1; si <= 3; si++) {
        sep = SEPS[si]
        if (index(s, sep) > 0) {
            n = split(s, parts, sep)
            if (n >= 2) {
                first = parts[1]
                if (first ~ /^[A-Za-z]+$/ && length(first) <= 12) {
                    result = first sep
                    for (i = 2; i <= n; i++) {
                        if (i > 2) result = result sep
                        result = result classify_segment(parts[i])
                    }
                    return result
                }
                result = classify_segment(parts[1])
                for (i = 2; i <= n; i++) {
                    result = result sep classify_segment(parts[i])
                }
                return result
            }
        }
    }

    return classify_segment(s)
}

# Redact known env values
function redact_env_values(line,    i, var, val, structure, replacement, escaped) {
    for (i = 1; i <= secrets_count; i++) {
        var = secrets_order[i]
        val = secrets[var]
        if (val == "") continue
        if (index(line, val) == 0) continue

        structure = describe_structure(val)
        replacement = "[REDACTED:" var ":" structure "]"
        # Escape special regex chars in val
        escaped = val
        gsub(/[[\\.^$*+?{}|()]/, "\\\\&", escaped)
        gsub(escaped, replacement, line)
    }
    return line
}

# Redact known token patterns
function redact_patterns(line,    structure, arr, prefix, suffix, pos, len) {
    # GitHub
    line = gensub(/ghp_[A-Za-z0-9]{36}/, "[REDACTED:GITHUB_PAT:ghp_36X]", "g", line)
    line = gensub(/gho_[A-Za-z0-9]{36}/, "[REDACTED:GITHUB_OAUTH:gho_36X]", "g", line)
    line = gensub(/ghs_[A-Za-z0-9]{36}/, "[REDACTED:GITHUB_SERVER:ghs_36X]", "g", line)
    line = gensub(/ghr_[A-Za-z0-9]{36}/, "[REDACTED:GITHUB_REFRESH:ghr_36X]", "g", line)
    line = gensub(/github_pat_[A-Za-z0-9_]{22,}/, "[REDACTED:GITHUB_PAT:github_pat_...]", "g", line)

    # GitLab
    line = gensub(/glpat-[A-Za-z0-9_-]{20,}/, "[REDACTED:GITLAB_PAT:glpat-...]", "g", line)

    # Slack
    line = gensub(/xoxb-[0-9]+-[0-9A-Za-z-]+/, "[REDACTED:SLACK_BOT:xoxb-...]", "g", line)
    line = gensub(/xoxp-[0-9]+-[0-9A-Za-z-]+/, "[REDACTED:SLACK_USER:xoxp-...]", "g", line)
    line = gensub(/xoxa-[0-9]+-[0-9A-Za-z-]+/, "[REDACTED:SLACK_APP:xoxa-...]", "g", line)
    line = gensub(/xoxs-[0-9]+-[0-9A-Za-z-]+/, "[REDACTED:SLACK_SESSION:xoxs-...]", "g", line)

    # OpenAI / Anthropic
    line = gensub(/sk-[A-Za-z0-9]{48}/, "[REDACTED:OPENAI_KEY:sk-48X]", "g", line)
    line = gensub(/sk-proj-[A-Za-z0-9_-]{20,}/, "[REDACTED:OPENAI_PROJECT_KEY:sk-proj-...]", "g", line)
    line = gensub(/sk-ant-[A-Za-z0-9-]{90,}/, "[REDACTED:ANTHROPIC_KEY:sk-ant-...]", "g", line)

    # AWS
    line = gensub(/AKIA[A-Z0-9]{16}/, "[REDACTED:AWS_ACCESS_KEY:AKIA16X]", "g", line)

    # Google Cloud
    line = gensub(/AIza[A-Za-z0-9_-]{35}/, "[REDACTED:GOOGLE_API_KEY:AIza35X]", "g", line)

    # age encryption
    line = gensub(/AGE-SECRET-KEY-[A-Z0-9]{59}/, "[REDACTED:AGE_SECRET_KEY:AGE-SECRET-KEY-59X]", "g", line)

    # Stripe
    line = gensub(/sk_live_[A-Za-z0-9]{24,}/, "[REDACTED:STRIPE_SECRET:sk_live_...]", "g", line)
    line = gensub(/sk_test_[A-Za-z0-9]{24,}/, "[REDACTED:STRIPE_TEST:sk_test_...]", "g", line)
    line = gensub(/pk_live_[A-Za-z0-9]{24,}/, "[REDACTED:STRIPE_PUBLISHABLE:pk_live_...]", "g", line)

    # Twilio
    line = gensub(/SK[a-f0-9]{32}/, "[REDACTED:TWILIO_KEY:SK32X]", "g", line)

    # SendGrid
    line = gensub(/SG\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/, "[REDACTED:SENDGRID_KEY:SG...]", "g", line)

    # npm / PyPI
    line = gensub(/npm_[A-Za-z0-9]{36}/, "[REDACTED:NPM_TOKEN:npm_36X]", "g", line)
    line = gensub(/pypi-[A-Za-z0-9_-]{100,}/, "[REDACTED:PYPI_TOKEN:pypi-...]", "g", line)

    # JWT tokens
    line = gensub(/eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/, "[REDACTED:JWT_TOKEN:eyJ...]", "g", line)

    # netrc/authinfo (capture group workaround for lookbehind)
    line = gensub(/(password )([^[:space:]]+)/, "\\1[REDACTED:NETRC_PASSWORD]", "g", line)
    line = gensub(/(passwd )([^[:space:]]+)/, "\\1[REDACTED:NETRC_PASSWORD]", "g", line)

    # Generic key=value patterns
    line = gensub(/(password=)([^[:space:],;"'\}\[\]]+)/, "\\1[REDACTED:PASSWORD_VALUE]", "g", line)
    line = gensub(/(password:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, "\\1\\2[REDACTED:PASSWORD_VALUE]", "g", line)
    line = gensub(/(Password=)([^[:space:],;"'\}\[\]]+)/, "\\1[REDACTED:PASSWORD_VALUE]", "g", line)
    line = gensub(/(Password:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, "\\1\\2[REDACTED:PASSWORD_VALUE]", "g", line)
    line = gensub(/(secret=)([^[:space:],;"'\}\[\]]+)/, "\\1[REDACTED:SECRET_VALUE]", "g", line)
    line = gensub(/(secret:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, "\\1\\2[REDACTED:SECRET_VALUE]", "g", line)
    line = gensub(/(Secret=)([^[:space:],;"'\}\[\]]+)/, "\\1[REDACTED:SECRET_VALUE]", "g", line)
    line = gensub(/(Secret:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, "\\1\\2[REDACTED:SECRET_VALUE]", "g", line)
    line = gensub(/(token=)([^[:space:],;"'\}\[\]]+)/, "\\1[REDACTED:TOKEN_VALUE]", "g", line)
    line = gensub(/(token:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, "\\1\\2[REDACTED:TOKEN_VALUE]", "g", line)
    line = gensub(/(Token=)([^[:space:],;"'\}\[\]]+)/, "\\1[REDACTED:TOKEN_VALUE]", "g", line)
    line = gensub(/(Token:)([[:space:]]*)([^[:space:],;"'\}\[\]]+)/, "\\1\\2[REDACTED:TOKEN_VALUE]", "g", line)

    # Git credential URLs: ://user:password@ -> ://user:[REDACTED]@
    # Use match() to find and manually reconstruct
    while (match(line, /(:[/][/][^:]+:)([^@\[]+)(@)/, arr)) {
        structure = describe_structure(arr[2])
        prefix = arr[1]
        suffix = arr[3]
        pos = RSTART
        len = RLENGTH
        line = substr(line, 1, pos - 1) prefix "[REDACTED:GIT_CREDENTIAL:" structure "]" suffix substr(line, pos + len)
    }

    # Docker config auth
    while (match(line, /("auth":[[:space:]]*")([A-Za-z0-9+/=]{20,})(")/, arr)) {
        structure = describe_structure(arr[2])
        prefix = arr[1]
        suffix = arr[3]
        pos = RSTART
        len = RLENGTH
        line = substr(line, 1, pos - 1) prefix "[REDACTED:DOCKER_AUTH:" structure "]" suffix substr(line, pos + len)
    }

    return line
}

# Redact a single line
function redact_line(line) {
    line = redact_env_values(line)
    line = redact_patterns(line)
    return line
}

# Flush buffer with redaction
function flush_buffer(    i) {
    for (i = 1; i <= buffer_len; i++) {
        printf "%s\n", redact_line(buffer[i])
    }
    fflush()
    delete buffer
    buffer_len = 0
}

#!/usr/bin/env bash
# secrets-filter: Filter stdin for secrets, redact with labels
# Streaming mode with state machine for private keys
# Uses gsed (GNU sed) on macOS, sed on Linux
#
# Filter modes:
#   --filter=values    - redact known secret values from environment
#   --filter=patterns  - redact regex patterns (token formats)
#   --filter=all       - shorthand for both (default)
#   -f X               - short form
#
# Environment variables (override with --filter):
#   SECRETS_FILTER_VALUES=0|false|no    - disable values filter
#   SECRETS_FILTER_PATTERNS=0|false|no  - disable patterns filter
#
# Performance: Batches lines through single sed invocation instead of per-line

set -o pipefail

# Check if value is falsy (0, false, no - case insensitive)
is_falsy() {
    local val="${1,,}"  # lowercase
    [[ "$val" =~ ^(0|false|no)$ ]]
}

# Parse filter modes from CLI and environment
# Sets global: filter_values, filter_patterns
parse_filter_modes() {
    filter_values=true
    filter_patterns=true
    local cli_specified=false
    local valid_found=false
    local invalid_filters=()

    # Parse CLI arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --filter=*)
                cli_specified=true
                filter_values=false
                filter_patterns=false
                local filters="${1#--filter=}"
                IFS=',' read -ra parts <<< "$filters"
                for part in "${parts[@]}"; do
                    # Trim whitespace and lowercase
                    part="${part// /}"
                    part="${part,,}"
                    case "$part" in
                        values)
                            filter_values=true
                            valid_found=true
                            ;;
                        patterns)
                            filter_patterns=true
                            valid_found=true
                            ;;
                        all)
                            filter_values=true
                            filter_patterns=true
                            valid_found=true
                            ;;
                        *)
                            if [[ -n "$part" ]]; then
                                invalid_filters+=("$part")
                            fi
                            ;;
                    esac
                done
                ;;
            -f)
                cli_specified=true
                filter_values=false
                filter_patterns=false
                shift
                if [[ $# -gt 0 ]]; then
                    local filters="$1"
                    IFS=',' read -ra parts <<< "$filters"
                    for part in "${parts[@]}"; do
                        # Trim whitespace and lowercase
                        part="${part// /}"
                        part="${part,,}"
                        case "$part" in
                            values)
                                filter_values=true
                                valid_found=true
                                ;;
                            patterns)
                                filter_patterns=true
                                valid_found=true
                                ;;
                            all)
                                filter_values=true
                                filter_patterns=true
                                valid_found=true
                                ;;
                            *)
                                if [[ -n "$part" ]]; then
                                    invalid_filters+=("$part")
                                fi
                                ;;
                        esac
                    done
                fi
                ;;
        esac
        shift
    done

    # Warn about invalid filters
    for invalid in "${invalid_filters[@]}"; do
        echo "secrets-filter: unknown filter '$invalid', ignoring" >&2
    done

    # Error if CLI specified but no valid filters found
    if $cli_specified && ! $valid_found; then
        echo "secrets-filter: no valid filters specified" >&2
        exit 1
    fi

    # If no CLI specified, check environment variables
    if ! $cli_specified; then
        if [[ -n "${SECRETS_FILTER_VALUES:-}" ]] && is_falsy "$SECRETS_FILTER_VALUES"; then
            filter_values=false
        fi
        if [[ -n "${SECRETS_FILTER_PATTERNS:-}" ]] && is_falsy "$SECRETS_FILTER_PATTERNS"; then
            filter_patterns=false
        fi
    fi
}

# Use GNU sed (gsed on macOS, sed on Linux)
if command -v gsed &>/dev/null; then
    SED=gsed
else
    SED=sed
fi

# Constants
MAX_PRIVATE_KEY_BUFFER=100
LONG_THRESHOLD=50
BATCH_SIZE=50

# State
STATE_NORMAL=0
STATE_IN_PRIVATE_KEY=1
state=$STATE_NORMAL
declare -a key_buffer=()
declare -a line_buffer=()

# Load secrets from environment into associative array
declare -A secrets
load_secrets() {
    # Explicit list of known secret env vars
    local explicit=(
        GITHUB_TOKEN GH_TOKEN GITLAB_TOKEN GLAB_TOKEN BITBUCKET_TOKEN
        AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AZURE_CLIENT_SECRET
        OPENAI_API_KEY ANTHROPIC_API_KEY CLAUDE_API_KEY
        SLACK_TOKEN SLACK_BOT_TOKEN SLACK_WEBHOOK_URL
        NPM_TOKEN PYPI_TOKEN DOCKER_PASSWORD
        DATABASE_URL REDIS_URL MONGODB_URI
        JWT_SECRET SESSION_SECRET ENCRYPTION_KEY
        SENDGRID_API_KEY TWILIO_AUTH_TOKEN STRIPE_SECRET_KEY
    )

    # Check explicit vars
    local name value
    for name in "${explicit[@]}"; do
        value="${!name:-}"
        if [[ -n "$value" && ${#value} -ge 8 ]]; then
            secrets["$name"]="$value"
        fi
    done

    # Pattern match all env vars ending with secret-like suffixes
    while IFS='=' read -r name value; do
        [[ -z "$value" || ${#value} -lt 8 ]] && continue
        case "$name" in
            *_SECRET|*_PASSWORD|*_TOKEN|*_API_KEY|*_PRIVATE_KEY|*_AUTH|*_CREDENTIAL)
                secrets["$name"]="$value"
                ;;
        esac
    done < <(env)
}

# Describe token structure (simplified for performance)
describe_structure() {
    local s="$1" len=${#s}
    [[ -z "$s" ]] && return
    ((len >= LONG_THRESHOLD)) && { echo "${len}chars"; return; }
    [[ "$s" =~ ^[0-9]+$ ]] && { echo "${len}N"; return; }
    [[ "$s" =~ ^[A-Za-z]+$ ]] && { echo "${len}A"; return; }
    echo "${len}X"
}

# Build combined sed script: token patterns first, then env values
# Token patterns have priority to ensure consistent output labels
# Env values catch remaining secrets that don't match known patterns
# This is called ONCE at startup, not per-line
# Respects filter_patterns and filter_values global flags
build_combined_script() {
    # Part 1: Token patterns (run first for consistent labels)
    # Only include if patterns filter is enabled
    if $filter_patterns; then
        cat << 'SEDSCRIPT'
# GitHub
s/ghp_[A-Za-z0-9]{36}/[REDACTED:GITHUB_PAT:ghp_36X]/g
s/gho_[A-Za-z0-9]{36}/[REDACTED:GITHUB_OAUTH:gho_36X]/g
s/ghs_[A-Za-z0-9]{36}/[REDACTED:GITHUB_SERVER:ghs_36X]/g
s/ghr_[A-Za-z0-9]{36}/[REDACTED:GITHUB_REFRESH:ghr_36X]/g
s/github_pat_[A-Za-z0-9_]{22,}/[REDACTED:GITHUB_PAT:github_pat_...]/g

# GitLab
s/glpat-[A-Za-z0-9_-]{20,}/[REDACTED:GITLAB_PAT:glpat_...]/g

# Slack
s/xoxb-[0-9]+-[0-9A-Za-z-]+/[REDACTED:SLACK_BOT:xoxb_...]/g
s/xoxp-[0-9]+-[0-9A-Za-z-]+/[REDACTED:SLACK_USER:xoxp_...]/g
s/xoxa-[0-9]+-[0-9A-Za-z-]+/[REDACTED:SLACK_APP:xoxa_...]/g
s/xoxs-[0-9]+-[0-9A-Za-z-]+/[REDACTED:SLACK_SESSION:xoxs_...]/g

# OpenAI / Anthropic
s/sk-[A-Za-z0-9]{48}/[REDACTED:OPENAI_KEY:sk_48X]/g
s/sk-proj-[A-Za-z0-9_-]{20,}/[REDACTED:OPENAI_PROJECT_KEY:sk-proj_...]/g
s/sk-ant-[A-Za-z0-9-]{90,}/[REDACTED:ANTHROPIC_KEY:sk-ant_...]/g

# AWS
s/AKIA[A-Z0-9]{16}/[REDACTED:AWS_ACCESS_KEY:AKIA16X]/g

# Google Cloud
s/AIza[A-Za-z0-9_-]{35}/[REDACTED:GOOGLE_API_KEY:AIza35X]/g

# age encryption
s/AGE-SECRET-KEY-[A-Z0-9]{59}/[REDACTED:AGE_SECRET_KEY:AGE-SECRET-KEY_59X]/g

# Stripe
s/sk_live_[A-Za-z0-9]{24,}/[REDACTED:STRIPE_SECRET:sk_live_...]/g
s/sk_test_[A-Za-z0-9]{24,}/[REDACTED:STRIPE_TEST:sk_test_...]/g
s/pk_live_[A-Za-z0-9]{24,}/[REDACTED:STRIPE_PUBLISHABLE:pk_live_...]/g

# Twilio
s/SK[a-f0-9]{32}/[REDACTED:TWILIO_KEY:SK32X]/g

# SendGrid
s/SG\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/[REDACTED:SENDGRID_KEY:SG...]/g

# npm / PyPI
s/npm_[A-Za-z0-9]{36}/[REDACTED:NPM_TOKEN:npm_36X]/g
s/pypi-[A-Za-z0-9_-]{100,}/[REDACTED:PYPI_TOKEN:pypi_...]/g

# JWT tokens
s/eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/[REDACTED:JWT_TOKEN:eyJ...]/g

# netrc/authinfo (using capture groups instead of lookbehind)
s/(password )([^[:space:]]+)/\1[REDACTED:NETRC_PASSWORD]/g
s/(passwd )([^[:space:]]+)/\1[REDACTED:NETRC_PASSWORD]/g

# Generic key=value patterns
# Use [^][:space:][]+  to exclude ], whitespace, [ - prevents matching [REDACTED:...]
s/(password=)([^][:space:][]+)/\1[REDACTED:PASSWORD_VALUE]/g
s/(password:)[[:space:]]*([^][:space:][]+)/\1[REDACTED:PASSWORD_VALUE]/g
s/(Password=)([^][:space:][]+)/\1[REDACTED:PASSWORD_VALUE]/g
s/(Password:)[[:space:]]*([^][:space:][]+)/\1[REDACTED:PASSWORD_VALUE]/g
s/(secret=)([^][:space:][]+)/\1[REDACTED:SECRET_VALUE]/g
s/(secret:)[[:space:]]*([^][:space:][]+)/\1[REDACTED:SECRET_VALUE]/g
s/(Secret=)([^][:space:][]+)/\1[REDACTED:SECRET_VALUE]/g
s/(Secret:)[[:space:]]*([^][:space:][]+)/\1[REDACTED:SECRET_VALUE]/g
s/(token=)([^][:space:][]+)/\1[REDACTED:TOKEN_VALUE]/g
s/(token:)[[:space:]]*([^][:space:][]+)/\1[REDACTED:TOKEN_VALUE]/g
s/(Token=)([^][:space:][]+)/\1[REDACTED:TOKEN_VALUE]/g
s/(Token:)[[:space:]]*([^][:space:][]+)/\1[REDACTED:TOKEN_VALUE]/g

# Git credential URLs
s|(://[^:]+:)([^@]+)(@)|\1[REDACTED:GIT_CREDENTIAL:hidden]\3|g

# Docker config auth
s|("auth":[[:space:]]*")([A-Za-z0-9+/=]{20,})(")|\1[REDACTED:DOCKER_AUTH:base64]\3|g
SEDSCRIPT
    fi

    # Part 2: Env value substitutions (longest first to prevent partial matches)
    # These run AFTER token patterns, catching any remaining secrets
    # Only include if values filter is enabled
    if $filter_values; then
        local sorted_vars var val structure escaped_val
        sorted_vars=$(for var in "${!secrets[@]}"; do
            echo "${#secrets[$var]} $var"
        done | sort -rn | cut -d' ' -f2)

        for var in $sorted_vars; do
            val="${secrets[$var]}"
            [[ -z "$val" ]] && continue
            structure=$(describe_structure "$val")
            # Escape special regex chars for sed (using | as delimiter, so escape | not /)
            escaped_val=$(printf '%s' "$val" | $SED 's/[[\.*^$()+?{|\\]/\\&/g; s/]/\\]/g')
            # Use | as delimiter to avoid conflicts with / in URLs and paths
            printf 's|%s|[REDACTED:%s:%s]|g\n' "$escaped_val" "$var" "$structure"
        done
    fi
}

# Flush line buffer through sed (single invocation for all buffered lines)
flush_line_buffer() {
    ((${#line_buffer[@]} > 0)) || return 0
    printf '%s\n' "${line_buffer[@]}" | $SED -E -f "$COMBINED_SCRIPT" 2>/dev/null || printf '%s\n' "${line_buffer[@]}"
    line_buffer=()
}

# Flush key buffer (for overflow case - redact each line)
flush_key_buffer() {
    local line
    for line in "${key_buffer[@]}"; do
        line_buffer+=("${line%$'\n'}")  # Remove trailing newline if present
    done
    key_buffer=()
}

# Main
main() {
    # Parse filter modes from CLI args (must be done before anything else)
    parse_filter_modes "$@"

    # Load secrets from environment (only if values filter is enabled)
    if $filter_values; then
        load_secrets
    fi

    # Build combined sed script ONCE at startup
    COMBINED_SCRIPT=$(mktemp)
    build_combined_script > "$COMBINED_SCRIPT"
    trap 'rm -f "$COMBINED_SCRIPT"' EXIT

    # Read all input upfront
    local input
    input=$(cat)

    # Empty input - nothing to do
    [[ -z "$input" ]] && return 0

    # Fast path: no private keys, skip state machine entirely
    if [[ "$input" != *"-----BEGIN"*"PRIVATE KEY-----"* ]]; then
        printf '%s' "$input" | $SED -E -f "$COMBINED_SCRIPT"
        return
    fi

    # Slow path: private keys present, need state machine
    while IFS= read -r line || [[ -n "$line" ]]; do
        case $state in
            $STATE_NORMAL)
                if [[ "$line" =~ -----BEGIN[[:space:]][A-Z[:space:]]*PRIVATE[[:space:]]KEY----- ]]; then
                    # Flush any pending normal lines before entering key state
                    flush_line_buffer
                    state=$STATE_IN_PRIVATE_KEY
                    key_buffer=("$line")
                else
                    line_buffer+=("$line")
                    ((${#line_buffer[@]} >= BATCH_SIZE)) && flush_line_buffer
                fi
                ;;
            $STATE_IN_PRIVATE_KEY)
                key_buffer+=("$line")

                if [[ "$line" =~ -----END[[:space:]][A-Z[:space:]]*PRIVATE[[:space:]]KEY----- ]]; then
                    printf '[REDACTED:PRIVATE_KEY:multiline]\n'
                    key_buffer=()
                    state=$STATE_NORMAL
                elif ((${#key_buffer[@]} > MAX_PRIVATE_KEY_BUFFER)); then
                    # Overflow: flush key buffer as normal lines
                    flush_key_buffer
                    ((${#line_buffer[@]} >= BATCH_SIZE)) && flush_line_buffer
                    state=$STATE_NORMAL
                fi
                ;;
        esac
    done <<< "$input"

    # EOF: flush remaining buffers
    flush_line_buffer
    if ((${#key_buffer[@]} > 0)); then
        flush_key_buffer
        flush_line_buffer
    fi
}

main "$@"

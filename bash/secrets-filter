#!/usr/bin/env bash
# secrets-filter: Filter stdin for secrets, redact with labels
# Streaming mode with state machine for private keys
# Uses gsed (GNU sed) on macOS, sed on Linux
#
# Filter modes:
#   --filter=values    - redact known secret values from environment
#   --filter=patterns  - redact regex patterns (token formats)
#   --filter=all       - shorthand for both (default)
#   -f X               - short form
#
# Environment variables (override with --filter):
#   SECRETS_FILTER_VALUES=0|false|no    - disable values filter
#   SECRETS_FILTER_PATTERNS=0|false|no  - disable patterns filter
#
# Performance: Batches lines through single sed invocation instead of per-line

set -o pipefail

# Check if value is falsy (0, false, no - case insensitive)
is_falsy() {
    local val="${1,,}"  # lowercase
    [[ "$val" =~ ^(0|false|no)$ ]]
}

# Parse filter modes from CLI and environment
# Sets global: filter_values, filter_patterns
parse_filter_modes() {
    filter_values=true
    filter_patterns=true
    local cli_specified=false
    local valid_found=false
    local invalid_filters=()

    # Parse CLI arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --filter=*)
                cli_specified=true
                filter_values=false
                filter_patterns=false
                local filters="${1#--filter=}"
                IFS=',' read -ra parts <<< "$filters"
                for part in "${parts[@]}"; do
                    # Trim whitespace and lowercase
                    part="${part// /}"
                    part="${part,,}"
                    case "$part" in
                        values)
                            filter_values=true
                            valid_found=true
                            ;;
                        patterns)
                            filter_patterns=true
                            valid_found=true
                            ;;
                        all)
                            filter_values=true
                            filter_patterns=true
                            valid_found=true
                            ;;
                        *)
                            if [[ -n "$part" ]]; then
                                invalid_filters+=("$part")
                            fi
                            ;;
                    esac
                done
                ;;
            -f)
                cli_specified=true
                filter_values=false
                filter_patterns=false
                shift
                if [[ $# -gt 0 ]]; then
                    local filters="$1"
                    IFS=',' read -ra parts <<< "$filters"
                    for part in "${parts[@]}"; do
                        # Trim whitespace and lowercase
                        part="${part// /}"
                        part="${part,,}"
                        case "$part" in
                            values)
                                filter_values=true
                                valid_found=true
                                ;;
                            patterns)
                                filter_patterns=true
                                valid_found=true
                                ;;
                            all)
                                filter_values=true
                                filter_patterns=true
                                valid_found=true
                                ;;
                            *)
                                if [[ -n "$part" ]]; then
                                    invalid_filters+=("$part")
                                fi
                                ;;
                        esac
                    done
                fi
                ;;
        esac
        shift
    done

    # Warn about invalid filters
    for invalid in "${invalid_filters[@]}"; do
        echo "secrets-filter: unknown filter '$invalid', ignoring" >&2
    done

    # Error if CLI specified but no valid filters found
    if $cli_specified && ! $valid_found; then
        echo "secrets-filter: no valid filters specified" >&2
        exit 1
    fi

    # If no CLI specified, check environment variables
    if ! $cli_specified; then
        if [[ -n "${SECRETS_FILTER_VALUES:-}" ]] && is_falsy "$SECRETS_FILTER_VALUES"; then
            filter_values=false
        fi
        if [[ -n "${SECRETS_FILTER_PATTERNS:-}" ]] && is_falsy "$SECRETS_FILTER_PATTERNS"; then
            filter_patterns=false
        fi
    fi
}

# Use GNU sed (gsed on macOS, sed on Linux)
if command -v gsed &>/dev/null; then
    SED=gsed
else
    SED=sed
fi

# Constants
MAX_PRIVATE_KEY_BUFFER=100
LONG_THRESHOLD=50
BATCH_SIZE=50

# State
STATE_NORMAL=0
STATE_IN_PRIVATE_KEY=1
state=$STATE_NORMAL
declare -a key_buffer=()
declare -a line_buffer=()

# Load secrets from environment into associative array
declare -A secrets
load_secrets() {
    # Explicit list of known secret env vars
    local explicit=(
        GITHUB_TOKEN GH_TOKEN GITLAB_TOKEN GLAB_TOKEN BITBUCKET_TOKEN
        AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AZURE_CLIENT_SECRET
        OPENAI_API_KEY ANTHROPIC_API_KEY CLAUDE_API_KEY
        SLACK_TOKEN SLACK_BOT_TOKEN SLACK_WEBHOOK_URL
        NPM_TOKEN PYPI_TOKEN DOCKER_PASSWORD
        DATABASE_URL REDIS_URL MONGODB_URI
        JWT_SECRET SESSION_SECRET ENCRYPTION_KEY
        SENDGRID_API_KEY TWILIO_AUTH_TOKEN STRIPE_SECRET_KEY
    )

    # Check explicit vars
    local name value
    for name in "${explicit[@]}"; do
        value="${!name:-}"
        if [[ -n "$value" && ${#value} -ge 8 ]]; then
            secrets["$name"]="$value"
        fi
    done

    # Pattern match all env vars ending with secret-like suffixes
    while IFS='=' read -r name value; do
        [[ -z "$value" || ${#value} -lt 8 ]] && continue
        case "$name" in
            *_SECRET|*_PASSWORD|*_TOKEN|*_API_KEY|*_PRIVATE_KEY|*_AUTH|*_CREDENTIAL)
                secrets["$name"]="$value"
                ;;
        esac
    done < <(env)
}

# Classify a single segment: N=digits, A=letters, X=mixed
classify_segment() {
    local s="$1"
    local len=${#s}
    [[ -z "$s" ]] && return
    if [[ "$s" =~ ^[0-9]+$ ]]; then
        echo "${len}N"
    elif [[ "$s" =~ ^[A-Za-z]+$ ]]; then
        echo "${len}A"
    else
        echo "${len}X"
    fi
}

# Describe token structure with separator and prefix handling
describe_structure() {
    local s="$1"
    local len=${#s}
    [[ -z "$s" ]] && return

    # Very long tokens: show length with prefix hint
    if ((len >= LONG_THRESHOLD)); then
        local sep parts first
        for sep in '-' '.' '_'; do
            if [[ "$s" == *"$sep"* ]]; then
                IFS="$sep" read -ra parts <<< "$s"
                first="${parts[0]}"
                if [[ "$first" =~ ^[A-Za-z]+$ ]] || [[ "$first" =~ ^(ghp|gho|ghs|ghr|npm|sk)$ ]]; then
                    echo "${first}${sep}...:${len}chars"
                    return
                fi
            fi
        done
        echo "${len}chars"
        return
    fi

    # Check for structured tokens with separators
    local sep parts first result i
    for sep in '-' '.' '_'; do
        if [[ "$s" == *"$sep"* ]]; then
            IFS="$sep" read -ra parts <<< "$s"
            if ((${#parts[@]} >= 2)); then
                first="${parts[0]}"
                # Keep alpha prefix if <= 12 chars
                if [[ "$first" =~ ^[A-Za-z]+$ ]] && ((${#first} <= 12)); then
                    result="${first}${sep}"
                    for ((i = 1; i < ${#parts[@]}; i++)); do
                        ((i > 1)) && result+="$sep"
                        result+=$(classify_segment "${parts[i]}")
                    done
                    echo "$result"
                    return
                fi
                # No prefix: classify all parts
                result=$(classify_segment "${parts[0]}")
                for ((i = 1; i < ${#parts[@]}; i++)); do
                    result+="${sep}$(classify_segment "${parts[i]}")"
                done
                echo "$result"
                return
            fi
        fi
    done

    # No separators: simple classification
    classify_segment "$s"
}

# Helper: replace first occurrence of pattern in line with replacement
# Uses bash regex matching - no external commands
# Arguments: line_var_name pattern label [capture_prefix] [capture_suffix]
replace_pattern() {
    local -n line_ref=$1
    local pattern="$2" label="$3" prefix="${4:-}" suffix="${5:-}"
    local matched structure

    while [[ "$line_ref" =~ $pattern ]]; do
        matched="${BASH_REMATCH[0]}"
        # Handle patterns with capture groups for context
        if [[ -n "$prefix" ]]; then
            # Context pattern: prefix + value (+ optional suffix)
            local ctx_prefix="${BASH_REMATCH[1]}"
            local ctx_value="${BASH_REMATCH[2]}"
            local ctx_suffix="${BASH_REMATCH[3]:-}"
            structure=$(describe_structure "$ctx_value")
            line_ref="${line_ref/"$matched"/"${ctx_prefix}[REDACTED:${label}:${structure}]${ctx_suffix}"}"
        else
            structure=$(describe_structure "$matched")
            line_ref="${line_ref/"$matched"/"[REDACTED:${label}:${structure}]"}"
        fi
    done
}

# Redact known token patterns from a single line
# Uses bash regex matching with dynamic structure calculation
redact_patterns_line() {
    local line="$1"

    # GitHub - fixed length
    replace_pattern line 'ghp_[A-Za-z0-9]{36}' 'GITHUB_PAT'
    replace_pattern line 'gho_[A-Za-z0-9]{36}' 'GITHUB_OAUTH'
    replace_pattern line 'ghs_[A-Za-z0-9]{36}' 'GITHUB_SERVER'
    replace_pattern line 'ghr_[A-Za-z0-9]{36}' 'GITHUB_REFRESH'

    # GitHub - variable length
    replace_pattern line 'github_pat_[A-Za-z0-9_]{22,}' 'GITHUB_PAT'

    # GitLab
    replace_pattern line 'glpat-[A-Za-z0-9_-]{20,}' 'GITLAB_PAT'

    # Slack
    replace_pattern line 'xoxb-[0-9]+-[0-9A-Za-z-]+' 'SLACK_BOT'
    replace_pattern line 'xoxp-[0-9]+-[0-9A-Za-z-]+' 'SLACK_USER'
    replace_pattern line 'xoxa-[0-9]+-[0-9A-Za-z-]+' 'SLACK_APP'
    replace_pattern line 'xoxs-[0-9]+-[0-9A-Za-z-]+' 'SLACK_SESSION'

    # OpenAI
    replace_pattern line 'sk-[A-Za-z0-9]{48}' 'OPENAI_KEY'
    replace_pattern line 'sk-proj-[A-Za-z0-9_-]{20,}' 'OPENAI_PROJECT_KEY'

    # Anthropic
    replace_pattern line 'sk-ant-[A-Za-z0-9-]{90,}' 'ANTHROPIC_KEY'

    # AWS
    replace_pattern line 'AKIA[A-Z0-9]{16}' 'AWS_ACCESS_KEY'

    # Google Cloud
    replace_pattern line 'AIza[A-Za-z0-9_-]{35}' 'GOOGLE_API_KEY'

    # age encryption
    replace_pattern line 'AGE-SECRET-KEY-[A-Z0-9]{59}' 'AGE_SECRET_KEY'

    # Stripe
    replace_pattern line 'sk_live_[A-Za-z0-9]{24,}' 'STRIPE_SECRET'
    replace_pattern line 'sk_test_[A-Za-z0-9]{24,}' 'STRIPE_TEST'
    replace_pattern line 'pk_live_[A-Za-z0-9]{24,}' 'STRIPE_PUBLISHABLE'

    # Twilio
    replace_pattern line 'SK[a-f0-9]{32}' 'TWILIO_KEY'

    # SendGrid - require min 10 chars per segment to avoid matching structure descriptions
    replace_pattern line 'SG\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}' 'SENDGRID_KEY'

    # npm
    replace_pattern line 'npm_[A-Za-z0-9]{36}' 'NPM_TOKEN'

    # PyPI
    replace_pattern line 'pypi-[A-Za-z0-9_-]{100,}' 'PYPI_TOKEN'

    # JWT tokens
    replace_pattern line 'eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+' 'JWT_TOKEN'

    # netrc/authinfo - context patterns (exclude [ to prevent re-matching [REDACTED:...])
    while [[ "$line" =~ (password[[:space:]])([^[:space:]\[]+) ]]; do
        local ctx_prefix="${BASH_REMATCH[1]}" ctx_value="${BASH_REMATCH[2]}"
        local structure=$(describe_structure "$ctx_value")
        line="${line/"${BASH_REMATCH[0]}"/"${ctx_prefix}[REDACTED:NETRC_PASSWORD:${structure}]"}"
    done
    while [[ "$line" =~ (passwd[[:space:]])([^[:space:]\[]+) ]]; do
        local ctx_prefix="${BASH_REMATCH[1]}" ctx_value="${BASH_REMATCH[2]}"
        local structure=$(describe_structure "$ctx_value")
        line="${line/"${BASH_REMATCH[0]}"/"${ctx_prefix}[REDACTED:NETRC_PASSWORD:${structure}]"}"
    done

    # Generic key=value patterns (exclude [ to prevent re-matching)
    # Key-value patterns for common secret formats
    # Note: In bash ERE, ] must come FIRST in a negated character class [^]...]
    # to be treated as a literal character
    # Note: For colon patterns, include leading whitespace in the value (like Python)
    local kv_patterns=(
        '(password=)([^][:space:],;"'\''}\[]+)' 'PASSWORD_VALUE'
        '(password:)([[:space:]]*[^][:space:],;"'\''}\[]+)' 'PASSWORD_VALUE'
        '(Password=)([^][:space:],;"'\''}\[]+)' 'PASSWORD_VALUE'
        '(Password:)([[:space:]]*[^][:space:],;"'\''}\[]+)' 'PASSWORD_VALUE'
        '(secret=)([^][:space:],;"'\''}\[]+)' 'SECRET_VALUE'
        '(secret:)([[:space:]]*[^][:space:],;"'\''}\[]+)' 'SECRET_VALUE'
        '(Secret=)([^][:space:],;"'\''}\[]+)' 'SECRET_VALUE'
        '(Secret:)([[:space:]]*[^][:space:],;"'\''}\[]+)' 'SECRET_VALUE'
        '(token=)([^][:space:],;"'\''}\[]+)' 'TOKEN_VALUE'
        '(token:)([[:space:]]*[^][:space:],;"'\''}\[]+)' 'TOKEN_VALUE'
        '(Token=)([^][:space:],;"'\''}\[]+)' 'TOKEN_VALUE'
        '(Token:)([[:space:]]*[^][:space:],;"'\''}\[]+)' 'TOKEN_VALUE'
    )
    local i
    for ((i = 0; i < ${#kv_patterns[@]}; i += 2)); do
        local pat="${kv_patterns[i]}" lbl="${kv_patterns[i+1]}"
        while [[ "$line" =~ $pat ]]; do
            local ctx_prefix="${BASH_REMATCH[1]}" ctx_value="${BASH_REMATCH[2]}"
            local structure=$(describe_structure "$ctx_value")
            line="${line/"${BASH_REMATCH[0]}"/"${ctx_prefix}[REDACTED:${lbl}:${structure}]"}"
        done
    done

    # Git credential URLs - exclude [ to prevent infinite loop
    # Note: In bash ERE, [ must come at end of negated class: [^@[]
    while [[ "$line" =~ (://[^:]+:)([^@[]+)(@) ]]; do
        local ctx_prefix="${BASH_REMATCH[1]}" ctx_value="${BASH_REMATCH[2]}" ctx_suffix="${BASH_REMATCH[3]}"
        local structure=$(describe_structure "$ctx_value")
        line="${line/"${BASH_REMATCH[0]}"/"${ctx_prefix}[REDACTED:GIT_CREDENTIAL:${structure}]${ctx_suffix}"}"
    done

    # Docker config auth
    while [[ "$line" =~ (\"auth\":[[:space:]]*\")([A-Za-z0-9+/=]{20,})(\") ]]; do
        local ctx_prefix="${BASH_REMATCH[1]}" ctx_value="${BASH_REMATCH[2]}" ctx_suffix="${BASH_REMATCH[3]}"
        local structure=$(describe_structure "$ctx_value")
        line="${line/"${BASH_REMATCH[0]}"/"${ctx_prefix}[REDACTED:DOCKER_AUTH:${structure}]${ctx_suffix}"}"
    done

    printf '%s' "$line"
}

# Build sed script for env value substitutions only
# This is called ONCE at startup
build_env_sed_script() {
    local sorted_vars var val structure escaped_val
    sorted_vars=$(for var in "${!secrets[@]}"; do
        echo "${#secrets[$var]} $var"
    done | sort -rn | cut -d' ' -f2)

    for var in $sorted_vars; do
        val="${secrets[$var]}"
        [[ -z "$val" ]] && continue
        structure=$(describe_structure "$val")
        # Escape special regex chars for sed ERE (using | as delimiter)
        # Note: | must be escaped as [|] not \| because \| means alternation in ERE
        escaped_val=$(printf '%s' "$val" | $SED 's/[[\.*^$()+?{\\]/\\&/g; s/]/\\]/g; s/|/[|]/g')
        printf 's|%s|[REDACTED:%s:%s]|g\n' "$escaped_val" "$var" "$structure"
    done
}

# Redact env values using sed (faster for bulk replacement)
redact_env_values() {
    if [[ -s "$ENV_SED_SCRIPT" ]]; then
        $SED -E -f "$ENV_SED_SCRIPT"
    else
        cat
    fi
}

# Redact a single line (env values first, then patterns - order matters!)
redact_line() {
    local line="$1"

    # Apply env values FIRST (to match Python behavior)
    if $filter_values && [[ -s "$ENV_SED_SCRIPT" ]]; then
        line=$(printf '%s' "$line" | $SED -E -f "$ENV_SED_SCRIPT")
    fi

    # Then apply patterns
    if $filter_patterns; then
        line=$(redact_patterns_line "$line")
    fi

    printf '%s' "$line"
}

# Flush line buffer with redaction
flush_line_buffer() {
    ((${#line_buffer[@]} > 0)) || return 0
    local line
    for line in "${line_buffer[@]}"; do
        redact_line "$line"
        printf '\n'
    done
    line_buffer=()
}

# Flush key buffer (for overflow case - redact each line)
flush_key_buffer() {
    local line
    for line in "${key_buffer[@]}"; do
        line_buffer+=("${line%$'\n'}")  # Remove trailing newline if present
    done
    key_buffer=()
}

# Process input line by line
process_input() {
    local line
    while IFS= read -r line || [[ -n "$line" ]]; do
        redact_line "$line"
        printf '\n'
    done
}

# Main
main() {
    # Parse filter modes from CLI args (must be done before anything else)
    parse_filter_modes "$@"

    # Load secrets from environment (only if values filter is enabled)
    if $filter_values; then
        load_secrets
    fi

    # Build env sed script ONCE at startup (only if values filter enabled)
    ENV_SED_SCRIPT=$(mktemp)
    if $filter_values; then
        build_env_sed_script > "$ENV_SED_SCRIPT"
    fi
    trap 'rm -f "$ENV_SED_SCRIPT"' EXIT

    # Read all input upfront
    local input
    input=$(cat)

    # Empty input - nothing to do
    [[ -z "$input" ]] && return 0

    # Fast path: no private keys, process line by line
    if [[ "$input" != *"-----BEGIN"*"PRIVATE KEY-----"* ]]; then
        process_input <<< "$input"
        return
    fi

    # Slow path: private keys present, need state machine
    while IFS= read -r line || [[ -n "$line" ]]; do
        case $state in
            $STATE_NORMAL)
                if $filter_patterns && [[ "$line" =~ -----BEGIN[[:space:]][A-Z[:space:]]*PRIVATE[[:space:]]KEY----- ]]; then
                    # Flush any pending normal lines before entering key state
                    flush_line_buffer
                    state=$STATE_IN_PRIVATE_KEY
                    key_buffer=("$line")
                else
                    line_buffer+=("$line")
                    ((${#line_buffer[@]} >= BATCH_SIZE)) && flush_line_buffer
                fi
                ;;
            $STATE_IN_PRIVATE_KEY)
                key_buffer+=("$line")

                if [[ "$line" =~ -----END[[:space:]][A-Z[:space:]]*PRIVATE[[:space:]]KEY----- ]]; then
                    printf '[REDACTED:PRIVATE_KEY:multiline]\n'
                    key_buffer=()
                    state=$STATE_NORMAL
                elif ((${#key_buffer[@]} > MAX_PRIVATE_KEY_BUFFER)); then
                    # Overflow: flush key buffer as normal lines
                    flush_key_buffer
                    ((${#line_buffer[@]} >= BATCH_SIZE)) && flush_line_buffer
                    state=$STATE_NORMAL
                fi
                ;;
        esac
    done <<< "$input"

    # EOF: flush remaining buffers
    flush_line_buffer
    if ((${#key_buffer[@]} > 0)); then
        flush_key_buffer
        flush_line_buffer
    fi
}

main "$@"

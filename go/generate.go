//go:build ignore

// generate.go reads YAML pattern definitions and generates patterns_gen.go
// Run: go run generate.go
package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "generate: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Find repo root (parent of go/)
	scriptDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("getwd: %w", err)
	}

	// Handle both running from go/ dir and repo root
	var repoRoot string
	if filepath.Base(scriptDir) == "go" {
		repoRoot = filepath.Dir(scriptDir)
	} else {
		repoRoot = scriptDir
	}

	patternsFile := filepath.Join(repoRoot, "patterns", "patterns.yaml")
	envFile := filepath.Join(repoRoot, "patterns", "env.yaml")
	outputFile := filepath.Join(repoRoot, "go", "patterns_gen.go")

	// Compute source hash
	hash, err := computeSourceHash(patternsFile, envFile)
	if err != nil {
		return fmt.Errorf("hash: %w", err)
	}

	// Read patterns.yaml
	constants, err := readConstants(patternsFile)
	if err != nil {
		return fmt.Errorf("constants: %w", err)
	}

	patterns, err := readPatterns(patternsFile)
	if err != nil {
		return fmt.Errorf("patterns: %w", err)
	}

	contextPatterns, err := readContextPatterns(patternsFile)
	if err != nil {
		return fmt.Errorf("context_patterns: %w", err)
	}

	specialPatterns, err := readSpecialPatterns(patternsFile)
	if err != nil {
		return fmt.Errorf("special_patterns: %w", err)
	}

	privateKey, err := readPrivateKeyMarkers(patternsFile)
	if err != nil {
		return fmt.Errorf("private_key: %w", err)
	}

	// Read env.yaml
	explicitEnvVars, err := readExplicitEnvVars(envFile)
	if err != nil {
		return fmt.Errorf("explicit env vars: %w", err)
	}

	envSuffixes, err := readEnvSuffixes(envFile)
	if err != nil {
		return fmt.Errorf("env suffixes: %w", err)
	}

	// Generate output
	var buf bytes.Buffer
	timestamp := time.Now().UTC().Format(time.RFC3339)

	buf.WriteString(fmt.Sprintf(`// Code generated by generate.go - DO NOT EDIT
// Generated: %s
// Source: patterns/*.yaml (hash: %s)
package main

import "regexp"

`, timestamp, hash[:12]))

	// Constants
	buf.WriteString(fmt.Sprintf("const LongThreshold = %d\n", constants.longThreshold))
	buf.WriteString(fmt.Sprintf("const MaxPrivateKeyBuffer = %d\n\n", constants.maxPrivateKeyBuffer))

	// Private key markers
	buf.WriteString("var (\n")
	buf.WriteString(fmt.Sprintf("\tprivateKeyBegin = regexp.MustCompile(`%s`)\n", privateKey.begin))
	buf.WriteString(fmt.Sprintf("\tprivateKeyEnd   = regexp.MustCompile(`%s`)\n", privateKey.end))
	buf.WriteString(")\n\n")

	// Pattern type
	buf.WriteString(`// Pattern holds a compiled regex and its label
type Pattern struct {
	Regex *regexp.Regexp
	Label string
}

`)

	// Direct patterns (skip multiline patterns - handled separately)
	buf.WriteString("// Direct patterns that can be matched without context\n")
	buf.WriteString("var patterns = []Pattern{\n")
	for _, p := range patterns {
		if p.multiline {
			continue // Skip multiline patterns in streaming mode
		}
		// Validate regex compiles
		if _, err := regexp.Compile(p.pattern); err != nil {
			return fmt.Errorf("invalid pattern %q: %w", p.pattern, err)
		}
		buf.WriteString(fmt.Sprintf("\t{regexp.MustCompile(`%s`), %q},\n", p.pattern, p.label))
	}
	buf.WriteString("}\n\n")

	// Context patterns (use capture groups since Go has no lookbehind)
	buf.WriteString("// Context patterns require prefix context (use capture groups since Go RE2 has no lookbehind)\n")
	buf.WriteString(`var contextPatterns = []struct {
	Regex *regexp.Regexp
	Label string
	Group int // which capture group contains the secret
}{
`)
	for _, cp := range contextPatterns {
		// Build pattern: (prefix)(value) with secret in group 2
		fullPattern := fmt.Sprintf("(%s)(%s)", escapeForRegex(cp.prefix), cp.value)
		// Validate regex compiles
		if _, err := regexp.Compile(fullPattern); err != nil {
			return fmt.Errorf("invalid context pattern %q: %w", fullPattern, err)
		}
		buf.WriteString(fmt.Sprintf("\t{regexp.MustCompile(`%s`), %q, 2},\n", fullPattern, cp.label))
	}
	buf.WriteString("}\n\n")

	// Special patterns
	buf.WriteString("// Special patterns with multiple capture groups\n")
	buf.WriteString("var (\n")
	for name, sp := range specialPatterns {
		// Validate regex compiles
		if _, err := regexp.Compile(sp.pattern); err != nil {
			return fmt.Errorf("invalid special pattern %s %q: %w", name, sp.pattern, err)
		}
		varName := toGoVarName(name) + "Pattern"
		buf.WriteString(fmt.Sprintf("\t%s = regexp.MustCompile(`%s`)\n", varName, sp.pattern))
	}
	buf.WriteString(")\n\n")

	// Explicit env vars as map for O(1) lookup
	buf.WriteString("// Explicit environment variable names known to contain secrets\n")
	buf.WriteString("var explicitEnvVars = map[string]bool{\n")
	for _, v := range explicitEnvVars {
		buf.WriteString(fmt.Sprintf("\t%q: true,\n", v))
	}
	buf.WriteString("}\n\n")

	// Env suffixes
	buf.WriteString("// Suffixes that indicate secret environment variables\n")
	buf.WriteString("var envSuffixes = []string{\n")
	for _, s := range envSuffixes {
		buf.WriteString(fmt.Sprintf("\t%q,\n", s))
	}
	buf.WriteString("}\n")

	// Write output file
	if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("write %s: %w", outputFile, err)
	}

	fmt.Printf("Generated %s (hash: %s)\n", outputFile, hash[:12])
	return nil
}

// computeSourceHash returns SHA256 hash of source files
func computeSourceHash(files ...string) (string, error) {
	h := sha256.New()
	for _, f := range files {
		data, err := os.ReadFile(f)
		if err != nil {
			return "", err
		}
		h.Write(data)
	}
	return hex.EncodeToString(h.Sum(nil)), nil
}

// yq runs yq with the given expression and file (trims trailing newline only)
func yq(expr, file string) (string, error) {
	cmd := exec.Command("yq", "-r", expr, file)
	out, err := cmd.Output()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			return "", fmt.Errorf("yq %s: %s", expr, exitErr.Stderr)
		}
		return "", err
	}
	// Trim only trailing newlines, preserve other whitespace (e.g., trailing space in "password ")
	result := strings.TrimRight(string(out), "\n")
	return result, nil
}

// yqLines runs yq and returns non-empty lines
func yqLines(expr, file string) ([]string, error) {
	out, err := yq(expr, file)
	if err != nil {
		return nil, err
	}
	if out == "" || out == "null" {
		return nil, nil
	}
	var lines []string
	for _, line := range strings.Split(out, "\n") {
		line = strings.TrimSpace(line)
		if line != "" && line != "null" {
			lines = append(lines, line)
		}
	}
	return lines, nil
}

type constants struct {
	longThreshold       int
	maxPrivateKeyBuffer int
}

func readConstants(file string) (constants, error) {
	var c constants

	lt, err := yq(".constants.long_threshold", file)
	if err != nil {
		return c, err
	}
	if _, err := fmt.Sscanf(lt, "%d", &c.longThreshold); err != nil {
		return c, fmt.Errorf("parse long_threshold: %w", err)
	}

	mpkb, err := yq(".constants.max_private_key_buffer", file)
	if err != nil {
		return c, err
	}
	if _, err := fmt.Sscanf(mpkb, "%d", &c.maxPrivateKeyBuffer); err != nil {
		return c, fmt.Errorf("parse max_private_key_buffer: %w", err)
	}

	return c, nil
}

type pattern struct {
	pattern   string
	label     string
	multiline bool
}

func readPatterns(file string) ([]pattern, error) {
	// Get count of patterns
	countStr, err := yq(".patterns | length", file)
	if err != nil {
		return nil, err
	}
	var count int
	if _, err := fmt.Sscanf(countStr, "%d", &count); err != nil {
		return nil, fmt.Errorf("parse pattern count: %w", err)
	}

	var patterns []pattern
	for i := 0; i < count; i++ {
		p, err := yq(fmt.Sprintf(".patterns[%d].pattern", i), file)
		if err != nil {
			return nil, err
		}
		l, err := yq(fmt.Sprintf(".patterns[%d].label", i), file)
		if err != nil {
			return nil, err
		}
		ml, _ := yq(fmt.Sprintf(".patterns[%d].multiline // false", i), file)
		patterns = append(patterns, pattern{
			pattern:   p,
			label:     l,
			multiline: ml == "true",
		})
	}
	return patterns, nil
}

type contextPattern struct {
	prefix string
	value  string
	label  string
}

func readContextPatterns(file string) ([]contextPattern, error) {
	countStr, err := yq(".context_patterns | length", file)
	if err != nil {
		return nil, err
	}
	var count int
	if _, err := fmt.Sscanf(countStr, "%d", &count); err != nil {
		return nil, fmt.Errorf("parse context_pattern count: %w", err)
	}

	var patterns []contextPattern
	for i := 0; i < count; i++ {
		prefix, err := yq(fmt.Sprintf(".context_patterns[%d].prefix", i), file)
		if err != nil {
			return nil, err
		}
		value, err := yq(fmt.Sprintf(".context_patterns[%d].value", i), file)
		if err != nil {
			return nil, err
		}
		label, err := yq(fmt.Sprintf(".context_patterns[%d].label", i), file)
		if err != nil {
			return nil, err
		}
		patterns = append(patterns, contextPattern{
			prefix: prefix,
			value:  value,
			label:  label,
		})
	}
	return patterns, nil
}

type specialPattern struct {
	pattern     string
	label       string
	secretGroup int
}

func readSpecialPatterns(file string) (map[string]specialPattern, error) {
	// Get keys
	keys, err := yqLines(".special_patterns | keys | .[]", file)
	if err != nil {
		return nil, err
	}

	patterns := make(map[string]specialPattern)
	for _, key := range keys {
		p, err := yq(fmt.Sprintf(".special_patterns.%s.pattern", key), file)
		if err != nil {
			return nil, err
		}
		l, err := yq(fmt.Sprintf(".special_patterns.%s.label", key), file)
		if err != nil {
			return nil, err
		}
		gStr, err := yq(fmt.Sprintf(".special_patterns.%s.secret_group", key), file)
		if err != nil {
			return nil, err
		}
		var g int
		if _, err := fmt.Sscanf(gStr, "%d", &g); err != nil {
			return nil, fmt.Errorf("parse secret_group for %s: %w", key, err)
		}
		patterns[key] = specialPattern{
			pattern:     p,
			label:       l,
			secretGroup: g,
		}
	}
	return patterns, nil
}

type privateKeyMarkers struct {
	begin string
	end   string
}

func readPrivateKeyMarkers(file string) (privateKeyMarkers, error) {
	begin, err := yq(".private_key.begin", file)
	if err != nil {
		return privateKeyMarkers{}, err
	}
	end, err := yq(".private_key.end", file)
	if err != nil {
		return privateKeyMarkers{}, err
	}
	return privateKeyMarkers{begin: begin, end: end}, nil
}

func readExplicitEnvVars(file string) ([]string, error) {
	return yqLines(".explicit[]", file)
}

func readEnvSuffixes(file string) ([]string, error) {
	return yqLines(".suffixes[]", file)
}

// escapeForRegex escapes special regex characters in a literal prefix
func escapeForRegex(s string) string {
	// Characters that need escaping in regex
	special := []string{"\\", ".", "+", "*", "?", "(", ")", "[", "]", "{", "}", "|", "^", "$"}
	for _, c := range special {
		s = strings.ReplaceAll(s, c, "\\"+c)
	}
	return s
}

// toGoVarName converts snake_case to camelCase
func toGoVarName(s string) string {
	parts := strings.Split(s, "_")
	for i := 1; i < len(parts); i++ {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

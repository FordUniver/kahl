//go:build ignore

// generate.go reads YAML pattern definitions and generates patterns_gen.go
// Run: go run generate.go
package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "generate: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Find repo root (parent of go/)
	scriptDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("getwd: %w", err)
	}

	// Handle both running from go/ dir and repo root
	var repoRoot string
	if filepath.Base(scriptDir) == "go" {
		repoRoot = filepath.Dir(scriptDir)
	} else {
		repoRoot = scriptDir
	}

	patternsFile := filepath.Join(repoRoot, "patterns", "patterns.yaml")
	envFile := filepath.Join(repoRoot, "patterns", "env.yaml")
	entropyFile := filepath.Join(repoRoot, "patterns", "entropy.yaml")
	outputFile := filepath.Join(repoRoot, "go", "patterns_gen.go")

	// Compute source hash
	hash, err := computeSourceHash(patternsFile, envFile, entropyFile)
	if err != nil {
		return fmt.Errorf("hash: %w", err)
	}

	// Read patterns.yaml
	constants, err := readConstants(patternsFile)
	if err != nil {
		return fmt.Errorf("constants: %w", err)
	}

	patterns, err := readPatterns(patternsFile)
	if err != nil {
		return fmt.Errorf("patterns: %w", err)
	}

	contextPatterns, err := readContextPatterns(patternsFile)
	if err != nil {
		return fmt.Errorf("context_patterns: %w", err)
	}

	specialPatterns, err := readSpecialPatterns(patternsFile)
	if err != nil {
		return fmt.Errorf("special_patterns: %w", err)
	}

	privateKey, err := readPrivateKeyMarkers(patternsFile)
	if err != nil {
		return fmt.Errorf("private_key: %w", err)
	}

	// Read env.yaml
	explicitEnvVars, err := readExplicitEnvVars(envFile)
	if err != nil {
		return fmt.Errorf("explicit env vars: %w", err)
	}

	envSuffixes, err := readEnvSuffixes(envFile)
	if err != nil {
		return fmt.Errorf("env suffixes: %w", err)
	}

	// Read entropy.yaml
	entropyConfig, err := readEntropyConfig(entropyFile)
	if err != nil {
		return fmt.Errorf("entropy config: %w", err)
	}

	// Generate output
	var buf bytes.Buffer
	timestamp := time.Now().UTC().Format(time.RFC3339)

	buf.WriteString(fmt.Sprintf(`// Code generated by generate.go - DO NOT EDIT
// Generated: %s
// Source: patterns/*.yaml (hash: %s)
package main

import "regexp"

`, timestamp, hash[:12]))

	// Constants
	buf.WriteString(fmt.Sprintf("const LongThreshold = %d\n", constants.longThreshold))
	buf.WriteString(fmt.Sprintf("const MaxPrivateKeyBuffer = %d\n\n", constants.maxPrivateKeyBuffer))

	// Private key markers
	buf.WriteString("var (\n")
	buf.WriteString(fmt.Sprintf("\tprivateKeyBegin = regexp.MustCompile(`%s`)\n", privateKey.begin))
	buf.WriteString(fmt.Sprintf("\tprivateKeyEnd   = regexp.MustCompile(`%s`)\n", privateKey.end))
	buf.WriteString(")\n\n")

	// Pattern type
	buf.WriteString(`// Pattern holds a compiled regex and its label
type Pattern struct {
	Regex *regexp.Regexp
	Label string
}

`)

	// Direct patterns (skip multiline patterns - handled separately)
	buf.WriteString("// Direct patterns that can be matched without context\n")
	buf.WriteString("var patterns = []Pattern{\n")
	for _, p := range patterns {
		if p.multiline {
			continue // Skip multiline patterns in streaming mode
		}
		// Validate regex compiles
		if _, err := regexp.Compile(p.pattern); err != nil {
			return fmt.Errorf("invalid pattern %q: %w", p.pattern, err)
		}
		buf.WriteString(fmt.Sprintf("\t{regexp.MustCompile(`%s`), %q},\n", p.pattern, p.label))
	}
	buf.WriteString("}\n\n")

	// Context patterns (use capture groups since Go has no lookbehind)
	buf.WriteString("// Context patterns require prefix context (use capture groups since Go RE2 has no lookbehind)\n")
	buf.WriteString(`var contextPatterns = []struct {
	Regex *regexp.Regexp
	Label string
	Group int // which capture group contains the secret
}{
`)
	for _, cp := range contextPatterns {
		// Build pattern: (prefix)(value) with secret in group 2
		fullPattern := fmt.Sprintf("(%s)(%s)", escapeForRegex(cp.prefix), cp.value)
		// Validate regex compiles
		if _, err := regexp.Compile(fullPattern); err != nil {
			return fmt.Errorf("invalid context pattern %q: %w", fullPattern, err)
		}
		buf.WriteString(fmt.Sprintf("\t{regexp.MustCompile(`%s`), %q, 2},\n", fullPattern, cp.label))
	}
	buf.WriteString("}\n\n")

	// Special patterns
	buf.WriteString("// Special patterns with multiple capture groups\n")
	buf.WriteString("var (\n")
	for name, sp := range specialPatterns {
		// Validate regex compiles
		if _, err := regexp.Compile(sp.pattern); err != nil {
			return fmt.Errorf("invalid special pattern %s %q: %w", name, sp.pattern, err)
		}
		varName := toGoVarName(name) + "Pattern"
		buf.WriteString(fmt.Sprintf("\t%s = regexp.MustCompile(`%s`)\n", varName, sp.pattern))
	}
	buf.WriteString(")\n\n")

	// Explicit env vars as map for O(1) lookup
	buf.WriteString("// Explicit environment variable names known to contain secrets\n")
	buf.WriteString("var explicitEnvVars = map[string]bool{\n")
	for _, v := range explicitEnvVars {
		buf.WriteString(fmt.Sprintf("\t%q: true,\n", v))
	}
	buf.WriteString("}\n\n")

	// Env suffixes
	buf.WriteString("// Suffixes that indicate secret environment variables\n")
	buf.WriteString("var envSuffixes = []string{\n")
	for _, s := range envSuffixes {
		buf.WriteString(fmt.Sprintf("\t%q,\n", s))
	}
	buf.WriteString("}\n\n")

	// Entropy configuration
	buf.WriteString("// Entropy detection configuration\n")
	if entropyConfig.enabledByDefault {
		buf.WriteString("const EntropyEnabledDefault = true\n")
	} else {
		buf.WriteString("const EntropyEnabledDefault = false\n")
	}
	buf.WriteString(fmt.Sprintf("const EntropyMinLength = %d\n", entropyConfig.minLength))
	buf.WriteString(fmt.Sprintf("const EntropyMaxLength = %d\n\n", entropyConfig.maxLength))

	buf.WriteString("// EntropyThresholds maps charset names to entropy thresholds\n")
	buf.WriteString("var EntropyThresholds = map[string]float64{\n")
	buf.WriteString(fmt.Sprintf("\t\"hex\":          %.1f,\n", entropyConfig.thresholds.hex))
	buf.WriteString(fmt.Sprintf("\t\"base64\":       %.1f,\n", entropyConfig.thresholds.base64))
	buf.WriteString(fmt.Sprintf("\t\"alphanumeric\": %.1f,\n", entropyConfig.thresholds.alphanumeric))
	buf.WriteString("}\n\n")

	buf.WriteString("// EntropyExclusion defines a pattern to exclude from entropy detection\n")
	buf.WriteString("type EntropyExclusion struct {\n")
	buf.WriteString("\tPattern         string\n")
	buf.WriteString("\tLabel           string\n")
	buf.WriteString("\tCaseInsensitive bool\n")
	buf.WriteString("\tContextKeywords []string\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// EntropyExclusions lists patterns to exclude from entropy detection\n")
	buf.WriteString("var EntropyExclusions = []EntropyExclusion{\n")
	for _, excl := range entropyConfig.exclusions {
		buf.WriteString("\t{\n")
		buf.WriteString(fmt.Sprintf("\t\tPattern:         %q,\n", excl.pattern))
		buf.WriteString(fmt.Sprintf("\t\tLabel:           %q,\n", excl.label))
		buf.WriteString(fmt.Sprintf("\t\tCaseInsensitive: %t,\n", excl.caseInsensitive))
		if len(excl.contextKeywords) > 0 {
			buf.WriteString("\t\tContextKeywords: []string{")
			for i, kw := range excl.contextKeywords {
				if i > 0 {
					buf.WriteString(", ")
				}
				buf.WriteString(fmt.Sprintf("%q", kw))
			}
			buf.WriteString("},\n")
		} else {
			buf.WriteString("\t\tContextKeywords: nil,\n")
		}
		buf.WriteString("\t},\n")
	}
	buf.WriteString("}\n\n")

	buf.WriteString("// EntropyContextKeywords is a map for quick keyword lookup\n")
	buf.WriteString("var EntropyContextKeywords = map[string]bool{\n")
	for _, kw := range entropyConfig.contextKeywords {
		buf.WriteString(fmt.Sprintf("\t%q: true,\n", kw))
	}
	buf.WriteString("}\n")

	// Write output file
	if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("write %s: %w", outputFile, err)
	}

	fmt.Printf("Generated %s (hash: %s)\n", outputFile, hash[:12])
	return nil
}

// computeSourceHash returns SHA256 hash of source files
func computeSourceHash(files ...string) (string, error) {
	h := sha256.New()
	for _, f := range files {
		data, err := os.ReadFile(f)
		if err != nil {
			return "", err
		}
		h.Write(data)
	}
	return hex.EncodeToString(h.Sum(nil)), nil
}

// yq runs yq with the given expression and file (trims trailing newline only)
func yq(expr, file string) (string, error) {
	cmd := exec.Command("yq", "-r", expr, file)
	out, err := cmd.Output()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			return "", fmt.Errorf("yq %s: %s", expr, exitErr.Stderr)
		}
		return "", err
	}
	// Trim only trailing newlines, preserve other whitespace (e.g., trailing space in "password ")
	result := strings.TrimRight(string(out), "\n")
	return result, nil
}

// yqLines runs yq and returns non-empty lines
func yqLines(expr, file string) ([]string, error) {
	out, err := yq(expr, file)
	if err != nil {
		return nil, err
	}
	if out == "" || out == "null" {
		return nil, nil
	}
	var lines []string
	for _, line := range strings.Split(out, "\n") {
		line = strings.TrimSpace(line)
		if line != "" && line != "null" {
			lines = append(lines, line)
		}
	}
	return lines, nil
}

type constants struct {
	longThreshold       int
	maxPrivateKeyBuffer int
}

func readConstants(file string) (constants, error) {
	var c constants

	lt, err := yq(".constants.long_threshold", file)
	if err != nil {
		return c, err
	}
	if _, err := fmt.Sscanf(lt, "%d", &c.longThreshold); err != nil {
		return c, fmt.Errorf("parse long_threshold: %w", err)
	}

	mpkb, err := yq(".constants.max_private_key_buffer", file)
	if err != nil {
		return c, err
	}
	if _, err := fmt.Sscanf(mpkb, "%d", &c.maxPrivateKeyBuffer); err != nil {
		return c, fmt.Errorf("parse max_private_key_buffer: %w", err)
	}

	return c, nil
}

type pattern struct {
	pattern   string
	label     string
	multiline bool
}

func readPatterns(file string) ([]pattern, error) {
	// Get count of patterns
	countStr, err := yq(".patterns | length", file)
	if err != nil {
		return nil, err
	}
	var count int
	if _, err := fmt.Sscanf(countStr, "%d", &count); err != nil {
		return nil, fmt.Errorf("parse pattern count: %w", err)
	}

	var patterns []pattern
	for i := 0; i < count; i++ {
		p, err := yq(fmt.Sprintf(".patterns[%d].pattern", i), file)
		if err != nil {
			return nil, err
		}
		l, err := yq(fmt.Sprintf(".patterns[%d].label", i), file)
		if err != nil {
			return nil, err
		}
		ml, _ := yq(fmt.Sprintf(".patterns[%d].multiline // false", i), file)
		patterns = append(patterns, pattern{
			pattern:   p,
			label:     l,
			multiline: ml == "true",
		})
	}
	return patterns, nil
}

type contextPattern struct {
	prefix string
	value  string
	label  string
}

func readContextPatterns(file string) ([]contextPattern, error) {
	countStr, err := yq(".context_patterns | length", file)
	if err != nil {
		return nil, err
	}
	var count int
	if _, err := fmt.Sscanf(countStr, "%d", &count); err != nil {
		return nil, fmt.Errorf("parse context_pattern count: %w", err)
	}

	var patterns []contextPattern
	for i := 0; i < count; i++ {
		prefix, err := yq(fmt.Sprintf(".context_patterns[%d].prefix", i), file)
		if err != nil {
			return nil, err
		}
		value, err := yq(fmt.Sprintf(".context_patterns[%d].value", i), file)
		if err != nil {
			return nil, err
		}
		label, err := yq(fmt.Sprintf(".context_patterns[%d].label", i), file)
		if err != nil {
			return nil, err
		}
		patterns = append(patterns, contextPattern{
			prefix: prefix,
			value:  value,
			label:  label,
		})
	}
	return patterns, nil
}

type specialPattern struct {
	pattern     string
	label       string
	secretGroup int
}

func readSpecialPatterns(file string) (map[string]specialPattern, error) {
	// Get keys
	keys, err := yqLines(".special_patterns | keys | .[]", file)
	if err != nil {
		return nil, err
	}

	patterns := make(map[string]specialPattern)
	for _, key := range keys {
		p, err := yq(fmt.Sprintf(".special_patterns.%s.pattern", key), file)
		if err != nil {
			return nil, err
		}
		l, err := yq(fmt.Sprintf(".special_patterns.%s.label", key), file)
		if err != nil {
			return nil, err
		}
		gStr, err := yq(fmt.Sprintf(".special_patterns.%s.secret_group", key), file)
		if err != nil {
			return nil, err
		}
		var g int
		if _, err := fmt.Sscanf(gStr, "%d", &g); err != nil {
			return nil, fmt.Errorf("parse secret_group for %s: %w", key, err)
		}
		patterns[key] = specialPattern{
			pattern:     p,
			label:       l,
			secretGroup: g,
		}
	}
	return patterns, nil
}

type privateKeyMarkers struct {
	begin string
	end   string
}

func readPrivateKeyMarkers(file string) (privateKeyMarkers, error) {
	begin, err := yq(".private_key.begin", file)
	if err != nil {
		return privateKeyMarkers{}, err
	}
	end, err := yq(".private_key.end", file)
	if err != nil {
		return privateKeyMarkers{}, err
	}
	return privateKeyMarkers{begin: begin, end: end}, nil
}

func readExplicitEnvVars(file string) ([]string, error) {
	return yqLines(".explicit[]", file)
}

func readEnvSuffixes(file string) ([]string, error) {
	return yqLines(".suffixes[]", file)
}

// escapeForRegex escapes special regex characters in a literal prefix
func escapeForRegex(s string) string {
	// Characters that need escaping in regex
	special := []string{"\\", ".", "+", "*", "?", "(", ")", "[", "]", "{", "}", "|", "^", "$"}
	for _, c := range special {
		s = strings.ReplaceAll(s, c, "\\"+c)
	}
	return s
}

// toGoVarName converts snake_case to camelCase
func toGoVarName(s string) string {
	parts := strings.Split(s, "_")
	for i := 1; i < len(parts); i++ {
		if len(parts[i]) > 0 {
			parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
		}
	}
	return strings.Join(parts, "")
}

// Entropy configuration types
type entropyThresholds struct {
	hex          float64
	base64       float64
	alphanumeric float64
}

type entropyExclusion struct {
	pattern         string
	label           string
	caseInsensitive bool
	contextKeywords []string
}

type entropyConfig struct {
	enabledByDefault bool
	thresholds       entropyThresholds
	minLength        int
	maxLength        int
	exclusions       []entropyExclusion
	contextKeywords  []string
}

func readEntropyConfig(file string) (entropyConfig, error) {
	var cfg entropyConfig

	// Check if file exists
	if _, err := os.Stat(file); os.IsNotExist(err) {
		// Return defaults if entropy.yaml doesn't exist
		cfg.enabledByDefault = false
		cfg.thresholds = entropyThresholds{hex: 3.0, base64: 4.5, alphanumeric: 4.5}
		cfg.minLength = 16
		cfg.maxLength = 256
		return cfg, nil
	}

	// enabled_by_default
	enabled, err := yq(".enabled_by_default // false", file)
	if err != nil {
		return cfg, err
	}
	cfg.enabledByDefault = enabled == "true"

	// Thresholds
	hexT, _ := yq(".thresholds.hex // 3.0", file)
	base64T, _ := yq(".thresholds.base64 // 4.5", file)
	alphanumT, _ := yq(".thresholds.alphanumeric // 4.5", file)

	fmt.Sscanf(hexT, "%f", &cfg.thresholds.hex)
	fmt.Sscanf(base64T, "%f", &cfg.thresholds.base64)
	fmt.Sscanf(alphanumT, "%f", &cfg.thresholds.alphanumeric)

	// Token length constraints
	minLen, _ := yq(".token_length.min // 16", file)
	maxLen, _ := yq(".token_length.max // 256", file)
	fmt.Sscanf(minLen, "%d", &cfg.minLength)
	fmt.Sscanf(maxLen, "%d", &cfg.maxLength)

	// Exclusions
	countStr, err := yq(".exclusions | length", file)
	if err != nil {
		return cfg, err
	}
	var count int
	fmt.Sscanf(countStr, "%d", &count)

	for i := 0; i < count; i++ {
		pattern, _ := yq(fmt.Sprintf(".exclusions[%d].pattern", i), file)
		label, _ := yq(fmt.Sprintf(".exclusions[%d].label", i), file)
		caseIns, _ := yq(fmt.Sprintf(".exclusions[%d].case_insensitive // false", i), file)

		// Check for context keywords
		kwCheck, _ := yq(fmt.Sprintf(".exclusions[%d].context_keywords // null", i), file)
		var keywords []string
		if kwCheck != "null" && kwCheck != "" {
			keywords, _ = yqLines(fmt.Sprintf(".exclusions[%d].context_keywords[]", i), file)
		}

		cfg.exclusions = append(cfg.exclusions, entropyExclusion{
			pattern:         pattern,
			label:           label,
			caseInsensitive: caseIns == "true",
			contextKeywords: keywords,
		})
	}

	// Global context keywords
	cfg.contextKeywords, _ = yqLines(".context_keywords[]", file)

	return cfg, nil
}

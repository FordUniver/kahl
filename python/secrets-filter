#!/usr/bin/env python3
"""Filter stdin: env lookup (precise labels) + pattern detection (catch-all).

Streaming mode: processes line-by-line with immediate flush.
State machine handles multiline private key blocks.
Binary detection triggers passthrough.

Dependencies: Python stdlib only (re, os, sys).

Filter modes:
  --filter=values    - redact known secret values from environment
  --filter=patterns  - redact regex patterns (token formats)
  --filter=all       - shorthand for both (default)

Environment variables (override with --filter):
  SECRETS_FILTER_VALUES=0|false|no    - disable values filter
  SECRETS_FILTER_PATTERNS=0|false|no  - disable patterns filter
"""
import os
import re
import subprocess
import sys
from pathlib import Path

# Ensure patterns_gen.py exists before importing
# Uses mtime comparison to avoid subprocess overhead on every invocation
SCRIPT_DIR = Path(__file__).parent
_patterns_gen = SCRIPT_DIR / "patterns_gen.py"
_generate_script = SCRIPT_DIR / "generate.py"
_patterns_yaml = SCRIPT_DIR.parent / "patterns" / "patterns.yaml"
_env_yaml = SCRIPT_DIR.parent / "patterns" / "env.yaml"

def _should_regenerate() -> bool:
    """Check if patterns_gen.py needs regeneration using mtime."""
    if not _patterns_gen.exists():
        return True
    gen_mtime = _patterns_gen.stat().st_mtime
    for src in [_patterns_yaml, _env_yaml]:
        if src.exists() and src.stat().st_mtime > gen_mtime:
            return True
    return False

if _generate_script.exists() and _should_regenerate():
    subprocess.run([sys.executable, str(_generate_script)], check=True)

# Import generated patterns
from patterns_gen import (
    CONTEXT_PATTERNS,
    ENV_SUFFIXES,
    EXPLICIT_ENV_VARS,
    LONG_THRESHOLD,
    MAX_PRIVATE_KEY_BUFFER,
    PATTERNS,
    PRIVATE_KEY_BEGIN,
    PRIVATE_KEY_END,
    SPECIAL_PATTERNS,
)

# Valid filter names
VALID_FILTERS = {'values', 'patterns', 'all'}


def is_env_disabled(name: str) -> bool:
    """Check if an environment variable is set to a falsy value."""
    val = os.environ.get(name, '')
    return val.lower() in ('0', 'false', 'no')


def parse_filter_arg(args: list[str]) -> tuple[set[str], bool]:
    """Parse --filter/-f argument from command line.

    Returns:
        (set of filter names, whether --filter was present)
    """
    filters = set()
    found = False

    i = 0
    while i < len(args):
        arg = args[i]
        value = None

        if arg.startswith('--filter='):
            value = arg[len('--filter='):]
            found = True
        elif arg == '--filter' or arg == '-f':
            if i + 1 < len(args):
                value = args[i + 1]
                i += 1
            found = True

        if value is not None:
            # Parse comma-separated, case-insensitive, whitespace-trimmed
            for part in value.split(','):
                f = part.strip().lower()
                if f:
                    filters.add(f)

        i += 1

    return filters, found


def get_enabled_filters() -> tuple[bool, bool]:
    """Determine which filters are enabled based on CLI and ENV.

    Returns:
        (values_enabled, patterns_enabled)
    """
    cli_filters, cli_present = parse_filter_arg(sys.argv[1:])

    if cli_present:
        # CLI overrides ENV entirely
        valid = set()
        invalid = []

        for f in cli_filters:
            if f in VALID_FILTERS:
                valid.add(f)
            else:
                invalid.append(f)

        # Warn about invalid filters
        for inv in invalid:
            print(f"secrets-filter: unknown filter '{inv}', ignoring", file=sys.stderr)

        # Error if no valid filters
        if not valid:
            print("secrets-filter: no valid filters specified", file=sys.stderr)
            sys.exit(1)

        # Expand 'all' to both filters
        if 'all' in valid:
            return True, True

        return 'values' in valid, 'patterns' in valid

    # No CLI: use environment variables (both enabled by default)
    values_enabled = not is_env_disabled('SECRETS_FILTER_VALUES')
    patterns_enabled = not is_env_disabled('SECRETS_FILTER_PATTERNS')

    return values_enabled, patterns_enabled


# State machine states
STATE_NORMAL = 0
STATE_IN_PRIVATE_KEY = 1

# Compile private key markers from imported strings
_PRIVATE_KEY_BEGIN_RE = re.compile(PRIVATE_KEY_BEGIN)
_PRIVATE_KEY_END_RE = re.compile(PRIVATE_KEY_END)

# Combined patterns list (direct + context patterns)
_ALL_PATTERNS = PATTERNS + CONTEXT_PATTERNS


def classify_segment(s: str) -> str:
    """Classify a segment: N=digits, A=letters, X=mixed."""
    if not s:
        return ''
    if s.isdigit():
        return f'{len(s)}N'
    if s.isalpha():
        return f'{len(s)}A'
    return f'{len(s)}X'


def describe_structure(s: str) -> str:
    """Describe token structure for redaction label.

    Examples:
        xoxb-123456789-987654321-abcdef -> xoxb-9N-9N-6X
        ghp_abc123def456... -> ghp_36X
        very_long_token... -> 108chars
    """
    # Very long tokens: just show length
    if len(s) >= LONG_THRESHOLD:
        # But still show prefix if there's a clear one
        for sep in ['-', '_', '.']:
            if sep in s:
                parts = s.split(sep)
                if parts[0].isalpha() or parts[0] in ('ghp', 'gho', 'ghs', 'ghr', 'npm', 'sk'):
                    return f'{parts[0]}{sep}...:{len(s)}chars'
        return f'{len(s)}chars'

    # Check for structured tokens (dash, underscore, or dot separated)
    for sep in ['-', '.', '_']:
        if sep in s:
            parts = s.split(sep)
            if len(parts) >= 2:
                # First part is likely a prefix if it's short alpha
                first = parts[0]
                if first.isalpha() and len(first) <= 12:
                    # Structured: prefix + segments
                    segments = [classify_segment(p) for p in parts[1:]]
                    return f'{first}{sep}' + sep.join(segments)
                # Otherwise describe all segments
                segments = [classify_segment(p) for p in parts]
                return sep.join(segments)

    # Simple token: just length + type
    return classify_segment(s)


def load_secrets() -> dict[str, str]:
    """Load secrets from environment variables.

    Checks explicit list of known secret variable names and pattern-matches
    variable names ending with common secret suffixes.
    Skips empty values and values shorter than 8 characters.
    """
    secrets = {}

    for name, value in os.environ.items():
        if not value or len(value) < 8:
            continue
        if name in EXPLICIT_ENV_VARS or any(name.endswith(p) for p in ENV_SUFFIXES):
            secrets[name] = value

    return secrets


def redact_env_values(text: str, secrets: dict[str, str]) -> str:
    """Replace known secret values with [REDACTED:VAR_NAME:structure], longest first."""
    # Sort by value length descending to handle overlaps
    for var, val in sorted(secrets.items(), key=lambda x: -len(x[1])):
        if val:  # skip empty values
            structure = describe_structure(val)
            text = text.replace(val, f'[REDACTED:{var}:{structure}]')
    return text


def redact_patterns(text: str) -> str:
    """Replace known token patterns with [REDACTED:LABEL:structure]."""
    # Apply direct patterns and context patterns
    for pattern, label in _ALL_PATTERNS:
        def make_replacement(m, lbl=label):
            matched = m.group(0)
            structure = describe_structure(matched)
            return f'[REDACTED:{lbl}:{structure}]'
        text = re.sub(pattern, make_replacement, text)

    # Special patterns requiring capture groups (variable-width context)
    for name, spec in SPECIAL_PATTERNS.items():
        pattern = spec['pattern']
        label = spec['label']
        secret_group = spec['secret_group']

        def make_special_replacement(m, lbl=label, grp=secret_group):
            structure = describe_structure(m.group(grp))
            # Reconstruct with all groups, replacing secret group
            parts = []
            for i in range(1, len(m.groups()) + 1):
                if i == grp:
                    parts.append(f'[REDACTED:{lbl}:{structure}]')
                else:
                    parts.append(m.group(i))
            return ''.join(parts)

        text = re.sub(pattern, make_special_replacement, text)

    return text


def redact_line(line: str, secrets: dict[str, str] | None,
                values_enabled: bool, patterns_enabled: bool) -> str:
    """Redact a single line using env values and/or patterns."""
    if values_enabled and secrets:
        line = redact_env_values(line, secrets)
    if patterns_enabled:
        line = redact_patterns(line)
    return line


def flush_buffer_redacted(buffer: list[str], secrets: dict[str, str] | None,
                          values_enabled: bool, patterns_enabled: bool) -> None:
    """Flush buffered lines, redacting each individually."""
    for line in buffer:
        sys.stdout.write(redact_line(line, secrets, values_enabled, patterns_enabled))
        sys.stdout.flush()


def main():
    """Stream stdin line-by-line with state machine for private keys."""
    # Determine which filters are enabled
    values_enabled, patterns_enabled = get_enabled_filters()

    # Load secrets only if values filter is enabled
    secrets = load_secrets() if values_enabled else None

    state = STATE_NORMAL
    buffer: list[str] = []

    for line in sys.stdin:
        # Binary detection: null byte means binary data
        if '\x00' in line:
            # Flush any buffered content
            if buffer:
                flush_buffer_redacted(buffer, secrets, values_enabled, patterns_enabled)
                buffer = []
            # Passthrough this line and rest of input unchanged
            sys.stdout.write(line)
            sys.stdout.flush()
            for rest in sys.stdin:
                sys.stdout.write(rest)
            return

        if state == STATE_NORMAL:
            if patterns_enabled and _PRIVATE_KEY_BEGIN_RE.search(line):
                # Start buffering private key block (only if patterns enabled)
                state = STATE_IN_PRIVATE_KEY
                buffer = [line]
            else:
                # Normal line: redact and output immediately
                sys.stdout.write(redact_line(line, secrets, values_enabled, patterns_enabled))
                sys.stdout.flush()

        elif state == STATE_IN_PRIVATE_KEY:
            buffer.append(line)

            if _PRIVATE_KEY_END_RE.search(line):
                # Complete private key block - emit single redaction
                sys.stdout.write('[REDACTED:PRIVATE_KEY:multiline]\n')
                sys.stdout.flush()
                buffer = []
                state = STATE_NORMAL

            elif len(buffer) > MAX_PRIVATE_KEY_BUFFER:
                # Buffer overflow - flush individually and return to normal
                flush_buffer_redacted(buffer, secrets, values_enabled, patterns_enabled)
                buffer = []
                state = STATE_NORMAL

    # EOF: flush any remaining buffer
    if buffer:
        flush_buffer_redacted(buffer, secrets, values_enabled, patterns_enabled)


if __name__ == '__main__':
    main()

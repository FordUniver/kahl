#!/usr/bin/env python3
"""Filter stdin: env lookup (precise labels) + pattern detection (catch-all).

Streaming mode: processes line-by-line with immediate flush.
State machine handles multiline private key blocks.
Binary detection triggers passthrough.

Dependencies: Python stdlib only (re, os, sys).

Filter modes:
  --filter=values    - redact known secret values from environment
  --filter=patterns  - redact regex patterns (token formats)
  --filter=all       - shorthand for both (default)

Environment variables (override with --filter):
  SECRETS_FILTER_VALUES=0|false|no    - disable values filter
  SECRETS_FILTER_PATTERNS=0|false|no  - disable patterns filter
"""
import os
import re
import sys

# Valid filter names
VALID_FILTERS = {'values', 'patterns', 'all'}


def is_env_disabled(name: str) -> bool:
    """Check if an environment variable is set to a falsy value."""
    val = os.environ.get(name, '')
    return val.lower() in ('0', 'false', 'no')


def parse_filter_arg(args: list[str]) -> tuple[set[str], bool]:
    """Parse --filter/-f argument from command line.

    Returns:
        (set of filter names, whether --filter was present)
    """
    filters = set()
    found = False

    i = 0
    while i < len(args):
        arg = args[i]
        value = None

        if arg.startswith('--filter='):
            value = arg[len('--filter='):]
            found = True
        elif arg == '--filter' or arg == '-f':
            if i + 1 < len(args):
                value = args[i + 1]
                i += 1
            found = True

        if value is not None:
            # Parse comma-separated, case-insensitive, whitespace-trimmed
            for part in value.split(','):
                f = part.strip().lower()
                if f:
                    filters.add(f)

        i += 1

    return filters, found


def get_enabled_filters() -> tuple[bool, bool]:
    """Determine which filters are enabled based on CLI and ENV.

    Returns:
        (values_enabled, patterns_enabled)
    """
    cli_filters, cli_present = parse_filter_arg(sys.argv[1:])

    if cli_present:
        # CLI overrides ENV entirely
        valid = set()
        invalid = []

        for f in cli_filters:
            if f in VALID_FILTERS:
                valid.add(f)
            else:
                invalid.append(f)

        # Warn about invalid filters
        for inv in invalid:
            print(f"secrets-filter: unknown filter '{inv}', ignoring", file=sys.stderr)

        # Error if no valid filters
        if not valid:
            print("secrets-filter: no valid filters specified", file=sys.stderr)
            sys.exit(1)

        # Expand 'all' to both filters
        if 'all' in valid:
            return True, True

        return 'values' in valid, 'patterns' in valid

    # No CLI: use environment variables (both enabled by default)
    values_enabled = not is_env_disabled('SECRETS_FILTER_VALUES')
    patterns_enabled = not is_env_disabled('SECRETS_FILTER_PATTERNS')

    return values_enabled, patterns_enabled


# State machine states
STATE_NORMAL = 0
STATE_IN_PRIVATE_KEY = 1

# Max lines to buffer for private key blocks
MAX_PRIVATE_KEY_BUFFER = 100

# Private key markers (for state machine)
PRIVATE_KEY_BEGIN = re.compile(r'-----BEGIN [A-Z ]*PRIVATE KEY-----')
PRIVATE_KEY_END = re.compile(r'-----END [A-Z ]*PRIVATE KEY-----')

# Known token patterns: (regex, label)
# Order: more specific patterns first
# Note: Private keys handled by state machine, not regex (multiline)
PATTERNS = [
    # GitHub
    (r'ghp_[A-Za-z0-9]{36}', 'GITHUB_PAT'),
    (r'gho_[A-Za-z0-9]{36}', 'GITHUB_OAUTH'),
    (r'ghs_[A-Za-z0-9]{36}', 'GITHUB_SERVER'),
    (r'ghr_[A-Za-z0-9]{36}', 'GITHUB_REFRESH'),
    (r'github_pat_[A-Za-z0-9_]{22,}', 'GITHUB_PAT'),

    # GitLab
    (r'glpat-[A-Za-z0-9_-]{20,}', 'GITLAB_PAT'),

    # Slack
    (r'xoxb-[0-9]+-[0-9A-Za-z-]+', 'SLACK_BOT'),
    (r'xoxp-[0-9]+-[0-9A-Za-z-]+', 'SLACK_USER'),
    (r'xoxa-[0-9]+-[0-9A-Za-z-]+', 'SLACK_APP'),
    (r'xoxs-[0-9]+-[0-9A-Za-z-]+', 'SLACK_SESSION'),

    # OpenAI / Anthropic
    (r'sk-[A-Za-z0-9]{48}', 'OPENAI_KEY'),
    (r'sk-proj-[A-Za-z0-9_-]{20,}', 'OPENAI_PROJECT_KEY'),
    (r'sk-ant-[A-Za-z0-9-]{90,}', 'ANTHROPIC_KEY'),

    # AWS
    (r'AKIA[A-Z0-9]{16}', 'AWS_ACCESS_KEY'),

    # Google Cloud
    (r'AIza[A-Za-z0-9_-]{35}', 'GOOGLE_API_KEY'),

    # age encryption
    (r'AGE-SECRET-KEY-[A-Z0-9]{59}', 'AGE_SECRET_KEY'),

    # Stripe
    (r'sk_live_[A-Za-z0-9]{24,}', 'STRIPE_SECRET'),
    (r'sk_test_[A-Za-z0-9]{24,}', 'STRIPE_TEST'),
    (r'pk_live_[A-Za-z0-9]{24,}', 'STRIPE_PUBLISHABLE'),

    # Twilio
    (r'SK[a-f0-9]{32}', 'TWILIO_KEY'),

    # SendGrid
    (r'SG\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+', 'SENDGRID_KEY'),

    # npm / PyPI
    (r'npm_[A-Za-z0-9]{36}', 'NPM_TOKEN'),
    (r'pypi-[A-Za-z0-9_-]{100,}', 'PYPI_TOKEN'),

    # JWT tokens (base64url header.payload.signature)
    (r'eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+', 'JWT_TOKEN'),

    # netrc/authinfo passwords (password/passwd followed by value)
    (r'(?<=password )[^\s]+', 'NETRC_PASSWORD'),
    (r'(?<=passwd )[^\s]+', 'NETRC_PASSWORD'),

    # Generic key=value patterns for common secret field names
    # Note: colon patterns include \s* to handle YAML-style "key: value" with space
    # Exclude [ to avoid matching [REDACTED:...] markers from earlier patterns
    (r'(?<=password=)[^\s,;"\'}\[\]]+', 'PASSWORD_VALUE'),
    (r'(?<=password:)\s*[^\s,;"\'}\[\]]+', 'PASSWORD_VALUE'),
    (r'(?<=Password=)[^\s,;"\'}\[\]]+', 'PASSWORD_VALUE'),
    (r'(?<=Password:)\s*[^\s,;"\'}\[\]]+', 'PASSWORD_VALUE'),
    (r'(?<=secret=)[^\s,;"\'}\[\]]+', 'SECRET_VALUE'),
    (r'(?<=secret:)\s*[^\s,;"\'}\[\]]+', 'SECRET_VALUE'),
    (r'(?<=Secret=)[^\s,;"\'}\[\]]+', 'SECRET_VALUE'),
    (r'(?<=Secret:)\s*[^\s,;"\'}\[\]]+', 'SECRET_VALUE'),
    (r'(?<=token=)[^\s,;"\'}\[\]]+', 'TOKEN_VALUE'),
    (r'(?<=token:)\s*[^\s,;"\'}\[\]]+', 'TOKEN_VALUE'),
    (r'(?<=Token=)[^\s,;"\'}\[\]]+', 'TOKEN_VALUE'),
    (r'(?<=Token:)\s*[^\s,;"\'}\[\]]+', 'TOKEN_VALUE'),

    # Private keys (SSH, PEM) - multiline regex for batch mode
    # In streaming mode, state machine handles this before redact_patterns() is called
    (r'-----BEGIN [A-Z ]*PRIVATE KEY-----[\s\S]*?-----END [A-Z ]*PRIVATE KEY-----', 'PRIVATE_KEY'),
]


# Length threshold for showing structure vs just "Nchars"
LONG_THRESHOLD = 50


def classify_segment(s: str) -> str:
    """Classify a segment: N=digits, A=letters, X=mixed."""
    if not s:
        return ''
    if s.isdigit():
        return f'{len(s)}N'
    if s.isalpha():
        return f'{len(s)}A'
    return f'{len(s)}X'


def describe_structure(s: str) -> str:
    """Describe token structure for redaction label.

    Examples:
        xoxb-123456789-987654321-abcdef -> xoxb-9N-9N-6X
        ghp_abc123def456... -> ghp_36X
        very_long_token... -> 108chars
    """
    # Very long tokens: just show length
    if len(s) >= LONG_THRESHOLD:
        # But still show prefix if there's a clear one
        for sep in ['-', '_', '.']:
            if sep in s:
                parts = s.split(sep)
                if parts[0].isalpha() or parts[0] in ('ghp', 'gho', 'ghs', 'ghr', 'npm', 'sk'):
                    return f'{parts[0]}{sep}...:{len(s)}chars'
        return f'{len(s)}chars'

    # Check for structured tokens (dash, underscore, or dot separated)
    for sep in ['-', '.', '_']:
        if sep in s:
            parts = s.split(sep)
            if len(parts) >= 2:
                # First part is likely a prefix if it's short alpha
                first = parts[0]
                if first.isalpha() and len(first) <= 12:
                    # Structured: prefix + segments
                    segments = [classify_segment(p) for p in parts[1:]]
                    return f'{first}{sep}' + sep.join(segments)
                # Otherwise describe all segments
                segments = [classify_segment(p) for p in parts]
                return sep.join(segments)

    # Simple token: just length + type
    return classify_segment(s)


def load_secrets() -> dict[str, str]:
    """Load secrets from environment variables.

    Checks explicit list of known secret variable names and pattern-matches
    variable names ending with common secret suffixes.
    Skips empty values and values shorter than 8 characters.
    """
    secrets = {}

    # Explicit set of known secret variable names
    explicit = {
        'GITHUB_TOKEN', 'GH_TOKEN', 'GITLAB_TOKEN', 'GLAB_TOKEN', 'BITBUCKET_TOKEN',
        'AWS_SECRET_ACCESS_KEY', 'AWS_SESSION_TOKEN', 'AZURE_CLIENT_SECRET',
        'OPENAI_API_KEY', 'ANTHROPIC_API_KEY', 'CLAUDE_API_KEY',
        'SLACK_TOKEN', 'SLACK_BOT_TOKEN', 'SLACK_WEBHOOK_URL',
        'NPM_TOKEN', 'PYPI_TOKEN', 'DOCKER_PASSWORD',
        'DATABASE_URL', 'REDIS_URL', 'MONGODB_URI',
        'JWT_SECRET', 'SESSION_SECRET', 'ENCRYPTION_KEY',
        'SENDGRID_API_KEY', 'TWILIO_AUTH_TOKEN', 'STRIPE_SECRET_KEY',
    }

    # Patterns to match (variable name suffixes)
    patterns = ('_SECRET', '_PASSWORD', '_TOKEN', '_API_KEY', '_PRIVATE_KEY', '_AUTH', '_CREDENTIAL')

    for name, value in os.environ.items():
        if not value or len(value) < 8:
            continue
        if name in explicit or any(name.endswith(p) for p in patterns):
            secrets[name] = value

    return secrets


def redact_env_values(text: str, secrets: dict[str, str]) -> str:
    """Replace known secret values with [REDACTED:VAR_NAME:structure], longest first."""
    # Sort by value length descending to handle overlaps
    for var, val in sorted(secrets.items(), key=lambda x: -len(x[1])):
        if val:  # skip empty values
            structure = describe_structure(val)
            text = text.replace(val, f'[REDACTED:{var}:{structure}]')
    return text


def redact_patterns(text: str) -> str:
    """Replace known token patterns with [REDACTED:LABEL:structure]."""
    for pattern, label in PATTERNS:
        def make_replacement(m, lbl=label):
            matched = m.group(0)
            structure = describe_structure(matched)
            return f'[REDACTED:{lbl}:{structure}]'
        text = re.sub(pattern, make_replacement, text)

    # Special patterns requiring capture groups (variable-width context)
    # Git credential URLs: ://user:password@ -> ://user:[REDACTED]@
    def git_cred_repl(m):
        structure = describe_structure(m.group(2))
        return f'{m.group(1)}[REDACTED:GIT_CREDENTIAL:{structure}]{m.group(3)}'
    text = re.sub(r'(://[^:]+:)([^@]+)(@)', git_cred_repl, text)

    # Docker config auth: "auth": "base64" -> "auth": "[REDACTED]"
    def docker_auth_repl(m):
        structure = describe_structure(m.group(2))
        return f'{m.group(1)}[REDACTED:DOCKER_AUTH:{structure}]{m.group(3)}'
    text = re.sub(r'("auth":\s*")([A-Za-z0-9+/=]{20,})(")', docker_auth_repl, text)

    return text


def redact_line(line: str, secrets: dict[str, str] | None,
                values_enabled: bool, patterns_enabled: bool) -> str:
    """Redact a single line using env values and/or patterns."""
    if values_enabled and secrets:
        line = redact_env_values(line, secrets)
    if patterns_enabled:
        line = redact_patterns(line)
    return line


def flush_buffer_redacted(buffer: list[str], secrets: dict[str, str] | None,
                          values_enabled: bool, patterns_enabled: bool) -> None:
    """Flush buffered lines, redacting each individually."""
    for line in buffer:
        sys.stdout.write(redact_line(line, secrets, values_enabled, patterns_enabled))
        sys.stdout.flush()


def main():
    """Stream stdin line-by-line with state machine for private keys."""
    # Determine which filters are enabled
    values_enabled, patterns_enabled = get_enabled_filters()

    # Load secrets only if values filter is enabled
    secrets = load_secrets() if values_enabled else None

    state = STATE_NORMAL
    buffer: list[str] = []

    for line in sys.stdin:
        # Binary detection: null byte means binary data
        if '\x00' in line:
            # Flush any buffered content
            if buffer:
                flush_buffer_redacted(buffer, secrets, values_enabled, patterns_enabled)
                buffer = []
            # Passthrough this line and rest of input unchanged
            sys.stdout.write(line)
            sys.stdout.flush()
            for rest in sys.stdin:
                sys.stdout.write(rest)
            return

        if state == STATE_NORMAL:
            if patterns_enabled and PRIVATE_KEY_BEGIN.search(line):
                # Start buffering private key block (only if patterns enabled)
                state = STATE_IN_PRIVATE_KEY
                buffer = [line]
            else:
                # Normal line: redact and output immediately
                sys.stdout.write(redact_line(line, secrets, values_enabled, patterns_enabled))
                sys.stdout.flush()

        elif state == STATE_IN_PRIVATE_KEY:
            buffer.append(line)

            if PRIVATE_KEY_END.search(line):
                # Complete private key block - emit single redaction
                sys.stdout.write('[REDACTED:PRIVATE_KEY:multiline]\n')
                sys.stdout.flush()
                buffer = []
                state = STATE_NORMAL

            elif len(buffer) > MAX_PRIVATE_KEY_BUFFER:
                # Buffer overflow - flush individually and return to normal
                flush_buffer_redacted(buffer, secrets, values_enabled, patterns_enabled)
                buffer = []
                state = STATE_NORMAL

    # EOF: flush any remaining buffer
    if buffer:
        flush_buffer_redacted(buffer, secrets, values_enabled, patterns_enabled)


if __name__ == '__main__':
    main()

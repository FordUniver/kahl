#!/usr/bin/env python3
"""Filter stdin: env lookup (precise labels) + pattern detection (catch-all).

Streaming mode: processes line-by-line with immediate flush.
State machine handles multiline private key blocks.
Binary detection triggers passthrough.

Dependencies: Python stdlib only (re, os, sys, pathlib).
"""
import os
import re
import subprocess
import sys
from pathlib import Path

# State machine states
STATE_NORMAL = 0
STATE_IN_PRIVATE_KEY = 1

# Max lines to buffer for private key blocks
MAX_PRIVATE_KEY_BUFFER = 100

# Private key markers (for state machine)
PRIVATE_KEY_BEGIN = re.compile(r'-----BEGIN [A-Z ]*PRIVATE KEY-----')
PRIVATE_KEY_END = re.compile(r'-----END [A-Z ]*PRIVATE KEY-----')

# Known token patterns: (regex, label)
# Order: more specific patterns first
# Note: Private keys handled by state machine, not regex (multiline)
PATTERNS = [
    # GitHub
    (r'ghp_[A-Za-z0-9]{36}', 'GITHUB_PAT'),
    (r'gho_[A-Za-z0-9]{36}', 'GITHUB_OAUTH'),
    (r'ghs_[A-Za-z0-9]{36}', 'GITHUB_SERVER'),
    (r'ghr_[A-Za-z0-9]{36}', 'GITHUB_REFRESH'),
    (r'github_pat_[A-Za-z0-9_]{22,}', 'GITHUB_PAT'),

    # GitLab
    (r'glpat-[A-Za-z0-9_-]{20,}', 'GITLAB_PAT'),

    # Slack
    (r'xoxb-[0-9]+-[0-9A-Za-z-]+', 'SLACK_BOT'),
    (r'xoxp-[0-9]+-[0-9A-Za-z-]+', 'SLACK_USER'),
    (r'xoxa-[0-9]+-[0-9A-Za-z-]+', 'SLACK_APP'),
    (r'xoxs-[0-9]+-[0-9A-Za-z-]+', 'SLACK_SESSION'),

    # OpenAI / Anthropic
    (r'sk-[A-Za-z0-9]{48}', 'OPENAI_KEY'),
    (r'sk-proj-[A-Za-z0-9_-]{20,}', 'OPENAI_PROJECT_KEY'),
    (r'sk-ant-[A-Za-z0-9-]{90,}', 'ANTHROPIC_KEY'),

    # AWS
    (r'AKIA[A-Z0-9]{16}', 'AWS_ACCESS_KEY'),

    # Google Cloud
    (r'AIza[A-Za-z0-9_-]{35}', 'GOOGLE_API_KEY'),

    # age encryption
    (r'AGE-SECRET-KEY-[A-Z0-9]{59}', 'AGE_SECRET_KEY'),

    # Stripe
    (r'sk_live_[A-Za-z0-9]{24,}', 'STRIPE_SECRET'),
    (r'sk_test_[A-Za-z0-9]{24,}', 'STRIPE_TEST'),
    (r'pk_live_[A-Za-z0-9]{24,}', 'STRIPE_PUBLISHABLE'),

    # Twilio
    (r'SK[a-f0-9]{32}', 'TWILIO_KEY'),

    # SendGrid
    (r'SG\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+', 'SENDGRID_KEY'),

    # npm / PyPI
    (r'npm_[A-Za-z0-9]{36}', 'NPM_TOKEN'),
    (r'pypi-[A-Za-z0-9_-]{100,}', 'PYPI_TOKEN'),

    # JWT tokens (base64url header.payload.signature)
    (r'eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+', 'JWT_TOKEN'),

    # netrc/authinfo passwords (password/passwd followed by value)
    (r'(?<=password )[^\s]+', 'NETRC_PASSWORD'),
    (r'(?<=passwd )[^\s]+', 'NETRC_PASSWORD'),

    # Generic key=value patterns for common secret field names
    # Note: colon patterns include \s* to handle YAML-style "key: value" with space
    # Exclude [ to avoid matching [REDACTED:...] markers from earlier patterns
    (r'(?<=password=)[^\s,;"\'}\[\]]+', 'PASSWORD_VALUE'),
    (r'(?<=password:)\s*[^\s,;"\'}\[\]]+', 'PASSWORD_VALUE'),
    (r'(?<=Password=)[^\s,;"\'}\[\]]+', 'PASSWORD_VALUE'),
    (r'(?<=Password:)\s*[^\s,;"\'}\[\]]+', 'PASSWORD_VALUE'),
    (r'(?<=secret=)[^\s,;"\'}\[\]]+', 'SECRET_VALUE'),
    (r'(?<=secret:)\s*[^\s,;"\'}\[\]]+', 'SECRET_VALUE'),
    (r'(?<=Secret=)[^\s,;"\'}\[\]]+', 'SECRET_VALUE'),
    (r'(?<=Secret:)\s*[^\s,;"\'}\[\]]+', 'SECRET_VALUE'),
    (r'(?<=token=)[^\s,;"\'}\[\]]+', 'TOKEN_VALUE'),
    (r'(?<=token:)\s*[^\s,;"\'}\[\]]+', 'TOKEN_VALUE'),
    (r'(?<=Token=)[^\s,;"\'}\[\]]+', 'TOKEN_VALUE'),
    (r'(?<=Token:)\s*[^\s,;"\'}\[\]]+', 'TOKEN_VALUE'),

    # Private keys (SSH, PEM) - multiline regex for batch mode
    # In streaming mode, state machine handles this before redact_patterns() is called
    (r'-----BEGIN [A-Z ]*PRIVATE KEY-----[\s\S]*?-----END [A-Z ]*PRIVATE KEY-----', 'PRIVATE_KEY'),
]


# Length threshold for showing structure vs just "Nchars"
LONG_THRESHOLD = 50


def classify_segment(s: str) -> str:
    """Classify a segment: N=digits, A=letters, X=mixed."""
    if not s:
        return ''
    if s.isdigit():
        return f'{len(s)}N'
    if s.isalpha():
        return f'{len(s)}A'
    return f'{len(s)}X'


def describe_structure(s: str) -> str:
    """Describe token structure for redaction label.

    Examples:
        xoxb-123456789-987654321-abcdef -> xoxb-9N-9N-6X
        ghp_abc123def456... -> ghp_36X
        very_long_token... -> 108chars
    """
    # Very long tokens: just show length
    if len(s) >= LONG_THRESHOLD:
        # But still show prefix if there's a clear one
        for sep in ['-', '_', '.']:
            if sep in s:
                parts = s.split(sep)
                if parts[0].isalpha() or parts[0] in ('ghp', 'gho', 'ghs', 'ghr', 'npm', 'sk'):
                    return f'{parts[0]}{sep}...:{len(s)}chars'
        return f'{len(s)}chars'

    # Check for structured tokens (dash, underscore, or dot separated)
    for sep in ['-', '.', '_']:
        if sep in s:
            parts = s.split(sep)
            if len(parts) >= 2:
                # First part is likely a prefix if it's short alpha
                first = parts[0]
                if first.isalpha() and len(first) <= 12:
                    # Structured: prefix + segments
                    segments = [classify_segment(p) for p in parts[1:]]
                    return f'{first}{sep}' + sep.join(segments)
                # Otherwise describe all segments
                segments = [classify_segment(p) for p in parts]
                return sep.join(segments)

    # Simple token: just length + type
    return classify_segment(s)


def load_secrets_from_dotfiles() -> dict[str, str]:
    """Extract variable names from $DOTFILES/secrets/, return {name: value} for set vars.

    Reads directly from dotfiles each time (no temp file caching).
    Only returns variables that are actually set in the current environment.
    """
    dotfiles = os.environ.get('DOTFILES', str(Path.home() / '.dotfiles'))
    secrets_dir = Path(dotfiles) / 'secrets'

    if not secrets_dir.is_dir():
        return {}

    # Extract variable names from SOPS-encrypted env files
    # Pattern: lines starting with VAR_NAME= (encrypted or not)
    try:
        result = subprocess.run(
            ['grep', '-rh', r'^[A-Z_][A-Z0-9_]*=', str(secrets_dir)],
            capture_output=True,
            text=True,
            timeout=5,
        )
        lines = result.stdout.strip().split('\n') if result.stdout.strip() else []
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return {}

    # Extract just the variable names and look up their values
    secrets = {}
    for line in lines:
        if '=' in line:
            var = line.split('=', 1)[0].strip()
            if var and var in os.environ:
                secrets[var] = os.environ[var]

    return secrets


def redact_env_values(text: str, secrets: dict[str, str]) -> str:
    """Replace known secret values with [REDACTED:VAR_NAME:structure], longest first."""
    # Sort by value length descending to handle overlaps
    for var, val in sorted(secrets.items(), key=lambda x: -len(x[1])):
        if val:  # skip empty values
            structure = describe_structure(val)
            text = text.replace(val, f'[REDACTED:{var}:{structure}]')
    return text


def redact_patterns(text: str) -> str:
    """Replace known token patterns with [REDACTED:LABEL:structure]."""
    for pattern, label in PATTERNS:
        def make_replacement(m, lbl=label):
            matched = m.group(0)
            structure = describe_structure(matched)
            return f'[REDACTED:{lbl}:{structure}]'
        text = re.sub(pattern, make_replacement, text)

    # Special patterns requiring capture groups (variable-width context)
    # Git credential URLs: ://user:password@ -> ://user:[REDACTED]@
    def git_cred_repl(m):
        structure = describe_structure(m.group(2))
        return f'{m.group(1)}[REDACTED:GIT_CREDENTIAL:{structure}]{m.group(3)}'
    text = re.sub(r'(://[^:]+:)([^@]+)(@)', git_cred_repl, text)

    # Docker config auth: "auth": "base64" -> "auth": "[REDACTED]"
    def docker_auth_repl(m):
        structure = describe_structure(m.group(2))
        return f'{m.group(1)}[REDACTED:DOCKER_AUTH:{structure}]{m.group(3)}'
    text = re.sub(r'("auth":\s*")([A-Za-z0-9+/=]{20,})(")', docker_auth_repl, text)

    return text


def redact_line(line: str, secrets: dict[str, str]) -> str:
    """Redact a single line using env values and patterns."""
    line = redact_env_values(line, secrets)
    line = redact_patterns(line)
    return line


def flush_buffer_redacted(buffer: list[str], secrets: dict[str, str]) -> None:
    """Flush buffered lines, redacting each individually."""
    for line in buffer:
        sys.stdout.write(redact_line(line, secrets))
        sys.stdout.flush()


def main():
    """Stream stdin line-by-line with state machine for private keys."""
    # Load secrets once at startup
    secrets = load_secrets_from_dotfiles()

    state = STATE_NORMAL
    buffer: list[str] = []

    for line in sys.stdin:
        # Binary detection: null byte means binary data
        if '\x00' in line:
            # Flush any buffered content
            if buffer:
                flush_buffer_redacted(buffer, secrets)
                buffer = []
            # Passthrough this line and rest of input unchanged
            sys.stdout.write(line)
            sys.stdout.flush()
            for rest in sys.stdin:
                sys.stdout.write(rest)
            return

        if state == STATE_NORMAL:
            if PRIVATE_KEY_BEGIN.search(line):
                # Start buffering private key block
                state = STATE_IN_PRIVATE_KEY
                buffer = [line]
            else:
                # Normal line: redact and output immediately
                sys.stdout.write(redact_line(line, secrets))
                sys.stdout.flush()

        elif state == STATE_IN_PRIVATE_KEY:
            buffer.append(line)

            if PRIVATE_KEY_END.search(line):
                # Complete private key block - emit single redaction
                sys.stdout.write('[REDACTED:PRIVATE_KEY:multiline]\n')
                sys.stdout.flush()
                buffer = []
                state = STATE_NORMAL

            elif len(buffer) > MAX_PRIVATE_KEY_BUFFER:
                # Buffer overflow - flush individually and return to normal
                flush_buffer_redacted(buffer, secrets)
                buffer = []
                state = STATE_NORMAL

    # EOF: flush any remaining buffer
    if buffer:
        flush_buffer_redacted(buffer, secrets)


if __name__ == '__main__':
    main()

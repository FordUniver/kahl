#!/usr/bin/env perl
# Filter stdin: env lookup (precise labels) + pattern detection (catch-all).
# Streaming mode: processes line-by-line with immediate flush.
# State machine handles multiline private key blocks.
# Binary detection triggers passthrough.

use strict;
use warnings;
use File::Basename;
use Getopt::Long qw(:config no_ignore_case bundling);

# Auto-flush stdout
$| = 1;

# Auto-regenerate Patterns.pm if missing
my $script_dir = dirname(__FILE__);
my $patterns_pm = "$script_dir/Patterns.pm";
unless (-f $patterns_pm) {
    system($^X, "$script_dir/generate.pl") == 0
        or die "Failed to generate Patterns.pm\n";
}

# Import generated patterns
use lib dirname(__FILE__);
use Patterns qw(:all);

# State constants
my $STATE_NORMAL = 0;
my $STATE_IN_PRIVATE_KEY = 1;

# Filter mode configuration
my ($filter_values, $filter_patterns) = parse_filter_config();

# Check if env value is falsy (0, false, no)
sub is_env_falsy {
    my ($val) = @_;
    return 0 unless defined $val;
    return lc($val) =~ /^(0|false|no)$/;
}

# Parse filter configuration from CLI and ENV
sub parse_filter_config {
    my $filter_arg;

    # Parse CLI arguments
    GetOptions('filter|f=s' => \$filter_arg) or exit 1;

    my ($values_enabled, $patterns_enabled);

    if (defined $filter_arg) {
        # CLI overrides ENV entirely
        my @valid_filters;
        my @invalid_filters;

        for my $f (split /,/, $filter_arg) {
            $f =~ s/^\s+|\s+$//g;  # trim whitespace
            $f = lc($f);

            if ($f eq 'all') {
                push @valid_filters, 'values', 'patterns';
            } elsif ($f eq 'values' || $f eq 'patterns') {
                push @valid_filters, $f;
            } else {
                push @invalid_filters, $f;
            }
        }

        # Warn about invalid filters
        for my $inv (@invalid_filters) {
            warn "secrets-filter: unknown filter '$inv', ignoring\n";
        }

        # Error if no valid filters
        if (@valid_filters == 0) {
            warn "secrets-filter: no valid filters specified\n";
            exit 1;
        }

        # Enable based on valid filters
        my %valid_set = map { $_ => 1 } @valid_filters;
        $values_enabled = $valid_set{values} ? 1 : 0;
        $patterns_enabled = $valid_set{patterns} ? 1 : 0;
    } else {
        # Check ENV variables (default: enabled unless explicitly disabled)
        $values_enabled = is_env_falsy($ENV{SECRETS_FILTER_VALUES}) ? 0 : 1;
        $patterns_enabled = is_env_falsy($ENV{SECRETS_FILTER_PATTERNS}) ? 0 : 1;
    }

    return ($values_enabled, $patterns_enabled);
}

# Classify a segment: N=digits, A=letters, X=mixed
sub classify_segment {
    my ($s) = @_;
    return '' unless defined $s && length $s;
    return length($s) . 'N' if $s =~ /^\d+$/;
    return length($s) . 'A' if $s =~ /^[A-Za-z]+$/;
    return length($s) . 'X';
}

# Describe token structure for redaction label
sub describe_structure {
    my ($s) = @_;
    return '' unless defined $s;

    # Very long tokens: show length (with prefix hint if available)
    if (length($s) >= $LONG_THRESHOLD) {
        for my $sep ('-', '_', '.') {
            if (index($s, $sep) != -1) {
                my @parts = split(/\Q$sep\E/, $s);
                my $first = $parts[0];
                if ($first =~ /^[a-zA-Z]+$/ || $first =~ /^(ghp|gho|ghs|ghr|npm|sk)$/) {
                    return "$first$sep...:" . length($s) . "chars";
                }
            }
        }
        return length($s) . "chars";
    }

    # Check for structured tokens
    for my $sep ('-', '.', '_') {
        if (index($s, $sep) != -1) {
            my @parts = split(/\Q$sep\E/, $s);
            if (@parts >= 2) {
                my $first = $parts[0];
                if ($first =~ /^[A-Za-z]+$/ && length($first) <= 12) {
                    my @segments = map { classify_segment($_) } @parts[1..$#parts];
                    return "$first$sep" . join($sep, @segments);
                }
                my @segments = map { classify_segment($_) } @parts;
                return join($sep, @segments);
            }
        }
    }

    return classify_segment($s);
}

# Load secrets from environment variables
sub load_secrets {
    my %secrets;

    my %explicit_set = map { $_ => 1 } @EXPLICIT_ENV_VARS;

    # Build suffix regex from @ENV_SUFFIXES
    my $suffix_pattern = '(?:' . join('|', map { quotemeta } @ENV_SUFFIXES) . ')$';
    my $suffix_re = qr/$suffix_pattern/;

    for my $name (keys %ENV) {
        my $value = $ENV{$name};
        next unless defined $value && length($value) >= 8;

        if ($explicit_set{$name} || $name =~ $suffix_re) {
            $secrets{$name} = $value;
        }
    }

    return \%secrets;
}

# Replace known secret values with [REDACTED:VAR_NAME:structure]
sub redact_env_values {
    my ($text, $secrets) = @_;

    # Sort by value length descending
    for my $var (sort { length($secrets->{$b}) <=> length($secrets->{$a}) } keys %$secrets) {
        my $val = $secrets->{$var};
        next unless defined $val && $val ne '';
        my $structure = describe_structure($val);
        my $replacement = "[REDACTED:$var:$structure]";
        $text =~ s/\Q$val\E/$replacement/g;
    }

    return $text;
}

# Replace known token patterns
sub redact_patterns {
    my ($text) = @_;

    # Direct patterns
    for my $pattern_info (@PATTERNS) {
        my ($pattern, $label) = @$pattern_info;
        $text =~ s/$pattern/
            my $matched = $&;
            my $structure = describe_structure($matched);
            "[REDACTED:$label:$structure]"
        /ge;
    }

    # Context patterns (with lookbehind)
    for my $pattern_info (@CONTEXT_PATTERNS) {
        my ($pattern, $label) = @$pattern_info;
        $text =~ s/$pattern/
            my $matched = $&;
            my $structure = describe_structure($matched);
            "[REDACTED:$label:$structure]"
        /ge;
    }

    # Special patterns with capture groups
    for my $key (keys %SPECIAL_PATTERNS) {
        my $spec = $SPECIAL_PATTERNS{$key};
        my $pattern = $spec->{pattern};
        my $label = $spec->{label};
        my $secret_group = $spec->{secret_group};

        $text =~ s{$pattern}{
            my @captures = ($1, $2, $3, $4, $5);  # Capture up to 5 groups
            my $secret = $captures[$secret_group - 1];
            my $structure = describe_structure($secret);
            my $result = '';
            for my $i (0 .. $#captures) {
                last unless defined $captures[$i];
                if ($i == $secret_group - 1) {
                    $result .= "[REDACTED:$label:$structure]";
                } else {
                    $result .= $captures[$i];
                }
            }
            $result;
        }ge;
    }

    return $text;
}

# Redact a single line (respects filter settings)
sub redact_line {
    my ($line, $secrets) = @_;
    $line = redact_env_values($line, $secrets) if $filter_values;
    $line = redact_patterns($line) if $filter_patterns;
    return $line;
}

# Flush buffer with redaction
sub flush_buffer_redacted {
    my ($buffer, $secrets) = @_;
    for my $line (@$buffer) {
        print redact_line($line, $secrets);
    }
}

# Main
sub main {
    # Skip loading secrets if values filter disabled
    my $secrets = $filter_values ? load_secrets() : {};
    my $state = $STATE_NORMAL;
    my @buffer;

    while (my $line = <STDIN>) {
        # Binary detection: null byte means binary data
        if (index($line, "\0") != -1) {
            flush_buffer_redacted(\@buffer, $secrets) if @buffer;
            @buffer = ();
            print $line;
            # Passthrough rest
            while (<STDIN>) {
                print;
            }
            return;
        }

        if ($state == $STATE_NORMAL) {
            # Only use state machine for private keys if patterns filter enabled
            if ($filter_patterns && $line =~ $PRIVATE_KEY_BEGIN) {
                $state = $STATE_IN_PRIVATE_KEY;
                @buffer = ($line);
            } else {
                print redact_line($line, $secrets);
            }
        } elsif ($state == $STATE_IN_PRIVATE_KEY) {
            push @buffer, $line;

            if ($line =~ $PRIVATE_KEY_END) {
                print "[REDACTED:PRIVATE_KEY:multiline]\n";
                @buffer = ();
                $state = $STATE_NORMAL;
            } elsif (@buffer > $MAX_PRIVATE_KEY_BUFFER) {
                flush_buffer_redacted(\@buffer, $secrets);
                @buffer = ();
                $state = $STATE_NORMAL;
            }
        }
    }

    # EOF: flush remaining buffer
    flush_buffer_redacted(\@buffer, $secrets) if @buffer;
}

main();

#!/usr/bin/env perl
# Filter stdin: env lookup (precise labels) + pattern detection (catch-all).
# Streaming mode: processes line-by-line with immediate flush.
# State machine handles multiline private key blocks.
# Binary detection triggers passthrough.

use strict;
use warnings;
use utf8;
use open ':std', ':encoding(UTF-8)';
use File::Basename;
use Getopt::Long qw(:config no_ignore_case bundling);

# Auto-flush stdout
$| = 1;

# Auto-regenerate Patterns.pm if missing or broken at compile time
# Using BEGIN block with eval to avoid TOCTOU race condition
BEGIN {
    use File::Basename;
    my $script_dir = dirname(__FILE__);
    push @INC, $script_dir;

    # Try to load Patterns.pm; regenerate if missing or broken
    my $patterns_loaded = eval { require Patterns; 1 };
    unless ($patterns_loaded) {
        my $load_error = $@;
        # Try to regenerate
        system($^X, "$script_dir/generate.pl") == 0
            or die "Failed to generate Patterns.pm: $load_error\n";
        # Clear cached failure and retry
        delete $INC{'Patterns.pm'};
        require Patterns or die "Failed to load Patterns.pm after regeneration\n";
    }
    Patterns->import(':all');
}

# Valid filter names
my %VALID_FILTERS = map { $_ => 1 } qw(values patterns entropy all);

# State constants
my $STATE_NORMAL = 0;
my $STATE_IN_PRIVATE_KEY = 1;

# Filter mode configuration
my ($filter_values, $filter_patterns, $filter_entropy) = get_enabled_filters();

# Check if env value is falsy (0, false, no)
sub is_env_falsy {
    my ($val) = @_;
    return 0 unless defined $val;
    return lc($val) =~ /^(0|false|no)$/;
}

# Check if env value is truthy (1, true, yes)
sub is_env_enabled {
    my ($val) = @_;
    return 0 unless defined $val;
    return lc($val) =~ /^(1|true|yes)$/;
}

# Get enabled filters from CLI and ENV
sub get_enabled_filters {
    my $filter_arg;

    # Parse CLI arguments
    GetOptions('filter|f=s' => \$filter_arg) or exit 1;

    my ($values_enabled, $patterns_enabled, $entropy_enabled);

    if (defined $filter_arg) {
        # CLI overrides ENV entirely
        my @valid_filters;
        my @invalid_filters;

        for my $f (split /,/, $filter_arg) {
            $f =~ s/^\s+|\s+$//g;  # trim whitespace
            $f = lc($f);

            if (exists $VALID_FILTERS{$f}) {
                if ($f eq 'all') {
                    # 'all' expands to all filters (values + patterns + entropy)
                    push @valid_filters, 'values', 'patterns', 'entropy';
                } else {
                    push @valid_filters, $f;
                }
            } else {
                push @invalid_filters, $f;
            }
        }

        # Warn about invalid filters
        for my $inv (@invalid_filters) {
            warn "secrets-filter: unknown filter '$inv', ignoring\n";
        }

        # Error if no valid filters
        if (@valid_filters == 0) {
            warn "secrets-filter: no valid filters specified\n";
            exit 1;
        }

        # Enable based on valid filters
        my %valid_set = map { $_ => 1 } @valid_filters;
        $values_enabled = $valid_set{values} ? 1 : 0;
        $patterns_enabled = $valid_set{patterns} ? 1 : 0;
        $entropy_enabled = $valid_set{entropy} ? 1 : 0;
    } else {
        # Check ENV variables
        # values and patterns: enabled by default unless explicitly disabled
        # entropy: disabled by default unless explicitly enabled
        $values_enabled = is_env_falsy($ENV{SECRETS_FILTER_VALUES}) ? 0 : 1;
        $patterns_enabled = is_env_falsy($ENV{SECRETS_FILTER_PATTERNS}) ? 0 : 1;
        $entropy_enabled = $ENTROPY_ENABLED_DEFAULT || is_env_enabled($ENV{SECRETS_FILTER_ENTROPY}) ? 1 : 0;
    }

    return ($values_enabled, $patterns_enabled, $entropy_enabled);
}

# Classify a segment: N=digits, A=letters, X=mixed
sub classify_segment {
    my ($s) = @_;
    return '' unless defined $s && length $s;
    return length($s) . 'N' if $s =~ /^\d+$/;
    return length($s) . 'A' if $s =~ /^[A-Za-z]+$/;
    return length($s) . 'X';
}

# Describe token structure for redaction label
sub describe_structure {
    my ($s) = @_;
    return '' unless defined $s;

    # Very long tokens: show length (with prefix hint if available)
    if (length($s) >= $LONG_THRESHOLD) {
        for my $sep ('-', '_', '.') {
            if (index($s, $sep) != -1) {
                my @parts = split(/\Q$sep\E/, $s);
                my $first = $parts[0];
                if ($first =~ /^[a-zA-Z]+$/ || $first =~ /^(ghp|gho|ghs|ghr|npm|sk)$/) {
                    return "$first$sep...:" . length($s) . "chars";
                }
            }
        }
        return length($s) . "chars";
    }

    # Check for structured tokens
    for my $sep ('-', '.', '_') {
        if (index($s, $sep) != -1) {
            my @parts = split(/\Q$sep\E/, $s);
            if (@parts >= 2) {
                my $first = $parts[0];
                if ($first =~ /^[A-Za-z]+$/ && length($first) <= 12) {
                    my @segments = map { classify_segment($_) } @parts[1..$#parts];
                    return "$first$sep" . join($sep, @segments);
                }
                my @segments = map { classify_segment($_) } @parts;
                return join($sep, @segments);
            }
        }
    }

    return classify_segment($s);
}

# Load secrets from environment variables
sub load_secrets {
    my %secrets;

    my %explicit_set = map { $_ => 1 } @EXPLICIT_ENV_VARS;

    # Build suffix regex from @ENV_SUFFIXES
    my $suffix_pattern = '(?:' . join('|', map { quotemeta } @ENV_SUFFIXES) . ')$';
    my $suffix_re = qr/$suffix_pattern/;

    for my $name (keys %ENV) {
        my $value = $ENV{$name};
        next unless defined $value && length($value) >= 8;

        if ($explicit_set{$name} || $name =~ $suffix_re) {
            $secrets{$name} = $value;
        }
    }

    return \%secrets;
}

# Replace known secret values with [REDACTED:VAR_NAME:structure]
sub redact_env_values {
    my ($text, $secrets) = @_;

    # Sort by value length descending
    for my $var (sort { length($secrets->{$b}) <=> length($secrets->{$a}) } keys %$secrets) {
        my $val = $secrets->{$var};
        next unless defined $val && $val ne '';
        my $structure = describe_structure($val);
        my $replacement = "[REDACTED:$var:$structure]";
        $text =~ s/\Q$val\E/$replacement/g;
    }

    return $text;
}

# Replace known token patterns
sub redact_patterns {
    my ($text) = @_;

    # Direct patterns
    for my $pattern_info (@PATTERNS) {
        my ($pattern, $label) = @$pattern_info;
        $text =~ s/$pattern/
            my $matched = $&;
            my $structure = describe_structure($matched);
            "[REDACTED:$label:$structure]"
        /ge;
    }

    # Context patterns (with lookbehind)
    for my $pattern_info (@CONTEXT_PATTERNS) {
        my ($pattern, $label) = @$pattern_info;
        $text =~ s/$pattern/
            my $matched = $&;
            my $structure = describe_structure($matched);
            "[REDACTED:$label:$structure]"
        /ge;
    }

    # Special patterns with capture groups
    for my $key (keys %SPECIAL_PATTERNS) {
        my $spec = $SPECIAL_PATTERNS{$key};
        my $pattern = $spec->{pattern};
        my $label = $spec->{label};
        my $secret_group = $spec->{secret_group};

        $text =~ s{$pattern}{
            my @captures = ($1, $2, $3, $4, $5);  # Capture up to 5 groups
            my $secret = $captures[$secret_group - 1];
            my $structure = describe_structure($secret);
            my $result = '';
            for my $i (0 .. $#captures) {
                last unless defined $captures[$i];
                if ($i == $secret_group - 1) {
                    $result .= "[REDACTED:$label:$structure]";
                } else {
                    $result .= $captures[$i];
                }
            }
            $result;
        }ge;
    }

    return $text;
}

# ============================================================================
# Entropy-based detection
# ============================================================================

# Character sets for classification
my %CHARSET_HEX = map { $_ => 1 } split //, '0123456789abcdef';
my %CHARSET_BASE64 = map { $_ => 1 } split //, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
my %CHARSET_ALNUM = map { $_ => 1 } split //, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-';

# Token extraction regex: split on delimiters
my $TOKEN_DELIM_RE = qr/[\s"'`()\[\]{},:;<>=\@#]+/;

# Calculate Shannon entropy of a string in bits
# H = -Σ p(x) log₂ p(x)
sub shannon_entropy {
    my ($s) = @_;
    return 0.0 unless defined $s && length $s;

    my %counts;
    $counts{$_}++ for split //, $s;

    my $length = length $s;
    my $entropy = 0.0;
    for my $count (values %counts) {
        my $p = $count / $length;
        $entropy -= $p * (log($p) / log(2));
    }
    return $entropy;
}

# Classify a string's character set
# Returns: 'hex', 'base64', 'alphanumeric', or 'mixed'
sub classify_charset {
    my ($s) = @_;
    my $lower = lc($s);
    my @chars = split //, $lower;
    my @upper_chars = split //, $s;

    # Check hex first (most restrictive)
    my $is_hex = 1;
    for my $c (@chars) {
        unless (exists $CHARSET_HEX{$c}) {
            $is_hex = 0;
            last;
        }
    }
    return 'hex' if $is_hex;

    # Check alphanumeric (common for tokens)
    my $is_alnum = 1;
    for my $c (@upper_chars) {
        unless (exists $CHARSET_ALNUM{$c}) {
            $is_alnum = 0;
            last;
        }
    }
    return 'alphanumeric' if $is_alnum;

    # Check base64
    my $is_base64 = 1;
    for my $c (@upper_chars) {
        unless (exists $CHARSET_BASE64{$c}) {
            $is_base64 = 0;
            last;
        }
    }
    return 'base64' if $is_base64;

    return 'mixed';
}

# Extract potential secret tokens from text
# Returns: list of [token, start_pos, end_pos]
sub extract_tokens {
    my ($text, $min_len, $max_len) = @_;
    my @tokens;

    # Split by delimiters while tracking positions
    my $pos = 0;
    for my $part (split /$TOKEN_DELIM_RE/, $text) {
        next unless defined $part && length $part;

        my $start = index($text, $part, $pos);
        next if $start < 0;
        my $end = $start + length($part);
        $pos = $end;

        # Filter by length
        my $len = length($part);
        next unless $len >= $min_len && $len <= $max_len;

        # Skip if all alphabetic (variable names)
        next if $part =~ /^[A-Za-z]+$/;

        # Skip if all numeric (IDs, line numbers)
        next if $part =~ /^\d+$/;

        push @tokens, [$part, $start, $end];
    }

    return @tokens;
}

# Check if a position in text is preceded by a context keyword
# Looks back up to 50 characters for any of the keywords
sub has_context_keyword {
    my ($text, $pos, $keywords_ref) = @_;
    return 0 unless $keywords_ref && @$keywords_ref;

    my $start = $pos > 50 ? $pos - 50 : 0;
    my $prefix = lc(substr($text, $start, $pos - $start));

    for my $kw (@$keywords_ref) {
        return 1 if index($prefix, lc($kw)) >= 0;
    }

    return 0;
}

# Check if token matches an exclusion pattern
# Returns: label if excluded, undef otherwise
sub matches_exclusion {
    my ($token, $text, $pos) = @_;

    for my $excl (@ENTROPY_EXCLUSIONS) {
        my $pattern = $excl->{pattern};
        if ($token =~ /^$pattern$/) {
            my $context_kw = $excl->{context_keywords};
            if ($context_kw) {
                # Has context keywords requirement
                if (has_context_keyword($text, $pos, $context_kw)) {
                    return $excl->{label};
                }
                # Has context keywords but none found - not excluded
                next;
            }
            # No context keywords required - excluded
            return $excl->{label};
        }
    }

    # Check global context keywords
    my @global_kw = keys %ENTROPY_CONTEXT_KEYWORDS;
    if (has_context_keyword($text, $pos, \@global_kw)) {
        return 'CONTEXT';
    }

    return undef;
}

# Create structure description for entropy redaction
# Example: hex:40:3.8
sub describe_entropy_structure {
    my ($token, $entropy, $charset) = @_;
    my %abbrev = (
        hex => 'hex',
        base64 => 'b64',
        alphanumeric => 'alnum',
        mixed => 'mix',
    );
    my $charset_abbrev = $abbrev{$charset} // $charset;
    return sprintf('%s:%d:%.1f', $charset_abbrev, length($token), $entropy);
}

# Get entropy configuration from environment overrides or defaults
sub get_entropy_config {
    my %config = (
        thresholds => { %ENTROPY_THRESHOLDS },
        min_length => $ENTROPY_MIN_LENGTH,
        max_length => $ENTROPY_MAX_LENGTH,
    );

    # Check for global threshold override
    my $global_t = $ENV{SECRETS_FILTER_ENTROPY_THRESHOLD};
    if (defined $global_t && $global_t =~ /^[\d.]+$/) {
        my $t = $global_t + 0;
        $config{thresholds} = { hex => $t, base64 => $t, alphanumeric => $t };
    }

    # Check for per-charset overrides
    for my $charset (qw(hex base64)) {
        my $env_name = 'SECRETS_FILTER_ENTROPY_' . uc($charset);
        my $val = $ENV{$env_name};
        if (defined $val && $val =~ /^[\d.]+$/) {
            $config{thresholds}{$charset} = $val + 0;
        }
    }

    # Length overrides
    my $min_len = $ENV{SECRETS_FILTER_ENTROPY_MIN_LEN};
    if (defined $min_len && $min_len =~ /^\d+$/) {
        $config{min_length} = $min_len + 0;
    }

    my $max_len = $ENV{SECRETS_FILTER_ENTROPY_MAX_LEN};
    if (defined $max_len && $max_len =~ /^\d+$/) {
        $config{max_length} = $max_len + 0;
    }

    return \%config;
}

# Detect and redact high-entropy strings
sub redact_entropy {
    my ($text, $config) = @_;

    my $min_len = $config->{min_length};
    my $max_len = $config->{max_length};
    my $thresholds = $config->{thresholds};

    my @tokens = extract_tokens($text, $min_len, $max_len);

    # Process in reverse order to preserve positions when replacing
    my @replacements;
    for my $token_info (reverse @tokens) {
        my ($token, $start, $end) = @$token_info;

        # Check exclusions
        my $excluded = matches_exclusion($token, $text, $start);
        next if $excluded;

        # Classify character set and get threshold
        my $charset = classify_charset($token);
        my $threshold;
        if ($charset eq 'mixed') {
            # Mixed character sets - use alphanumeric threshold
            $threshold = $thresholds->{alphanumeric} // 4.5;
        } else {
            $threshold = $thresholds->{$charset} // 4.5;
        }

        # Calculate entropy
        my $entropy = shannon_entropy($token);

        if ($entropy >= $threshold) {
            my $structure = describe_entropy_structure($token, $entropy, $charset);
            my $replacement = "[REDACTED:HIGH_ENTROPY:$structure]";
            push @replacements, [$start, $end, $replacement];
        }
    }

    # Apply replacements in reverse order
    for my $repl (@replacements) {
        my ($start, $end, $replacement) = @$repl;
        substr($text, $start, $end - $start) = $replacement;
    }

    return $text;
}

# Redact a single line (respects filter settings)
sub redact_line {
    my ($line, $secrets, $entropy_enabled, $entropy_config) = @_;
    $line = redact_env_values($line, $secrets) if $filter_values;
    $line = redact_patterns($line) if $filter_patterns;
    $line = redact_entropy($line, $entropy_config) if $entropy_enabled;
    return $line;
}

# Flush buffer with redaction
sub flush_buffer_redacted {
    my ($buffer, $secrets, $entropy_enabled, $entropy_config) = @_;
    for my $line (@$buffer) {
        print redact_line($line, $secrets, $entropy_enabled, $entropy_config);
    }
}

# Main
sub main {
    # Skip loading secrets if values filter disabled
    my $secrets = $filter_values ? load_secrets() : {};

    # Load entropy config only if entropy filter is enabled
    my $entropy_config = $filter_entropy ? get_entropy_config() : undef;

    my $state = $STATE_NORMAL;
    my @buffer;

    while (my $line = <STDIN>) {
        # Binary detection: null byte means binary data
        if (index($line, "\0") != -1) {
            flush_buffer_redacted(\@buffer, $secrets, $filter_entropy, $entropy_config) if @buffer;
            @buffer = ();
            print $line;
            # Passthrough rest
            while (<STDIN>) {
                print;
            }
            return;
        }

        if ($state == $STATE_NORMAL) {
            # Only use state machine for private keys if patterns filter enabled
            if ($filter_patterns && $line =~ $PRIVATE_KEY_BEGIN) {
                $state = $STATE_IN_PRIVATE_KEY;
                @buffer = ($line);
            } else {
                print redact_line($line, $secrets, $filter_entropy, $entropy_config);
            }
        } elsif ($state == $STATE_IN_PRIVATE_KEY) {
            push @buffer, $line;

            if ($line =~ $PRIVATE_KEY_END) {
                print "[REDACTED:PRIVATE_KEY:multiline]\n";
                @buffer = ();
                $state = $STATE_NORMAL;
            } elsif (@buffer > $MAX_PRIVATE_KEY_BUFFER) {
                flush_buffer_redacted(\@buffer, $secrets, $filter_entropy, $entropy_config);
                @buffer = ();
                $state = $STATE_NORMAL;
            }
        }
    }

    # EOF: flush remaining buffer
    flush_buffer_redacted(\@buffer, $secrets, $filter_entropy, $entropy_config) if @buffer;
}

main();

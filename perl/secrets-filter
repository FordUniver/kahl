#!/usr/bin/env perl
# Filter stdin: env lookup (precise labels) + pattern detection (catch-all).
# Streaming mode: processes line-by-line with immediate flush.
# State machine handles multiline private key blocks.
# Binary detection triggers passthrough.

use strict;
use warnings;
use File::Basename;
use Getopt::Long qw(:config no_ignore_case bundling);

# Auto-flush stdout
$| = 1;

# Constants
my $STATE_NORMAL = 0;
my $STATE_IN_PRIVATE_KEY = 1;
my $MAX_PRIVATE_KEY_BUFFER = 100;
my $LONG_THRESHOLD = 50;

# Private key markers
my $PRIVATE_KEY_BEGIN = qr/-----BEGIN [A-Z ]*PRIVATE KEY-----/;
my $PRIVATE_KEY_END = qr/-----END [A-Z ]*PRIVATE KEY-----/;

# Filter mode configuration
my ($filter_values, $filter_patterns) = parse_filter_config();

# Known token patterns: [regex, label]
# Order: more specific patterns first
my @PATTERNS = (
    # GitHub
    [qr/ghp_[A-Za-z0-9]{36}/, 'GITHUB_PAT'],
    [qr/gho_[A-Za-z0-9]{36}/, 'GITHUB_OAUTH'],
    [qr/ghs_[A-Za-z0-9]{36}/, 'GITHUB_SERVER'],
    [qr/ghr_[A-Za-z0-9]{36}/, 'GITHUB_REFRESH'],
    [qr/github_pat_[A-Za-z0-9_]{22,}/, 'GITHUB_PAT'],

    # GitLab
    [qr/glpat-[A-Za-z0-9_-]{20,}/, 'GITLAB_PAT'],

    # Slack
    [qr/xoxb-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_BOT'],
    [qr/xoxp-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_USER'],
    [qr/xoxa-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_APP'],
    [qr/xoxs-[0-9]+-[0-9A-Za-z-]+/, 'SLACK_SESSION'],

    # OpenAI / Anthropic
    [qr/sk-[A-Za-z0-9]{48}/, 'OPENAI_KEY'],
    [qr/sk-proj-[A-Za-z0-9_-]{20,}/, 'OPENAI_PROJECT_KEY'],
    [qr/sk-ant-[A-Za-z0-9-]{90,}/, 'ANTHROPIC_KEY'],

    # AWS
    [qr/AKIA[A-Z0-9]{16}/, 'AWS_ACCESS_KEY'],

    # Google Cloud
    [qr/AIza[A-Za-z0-9_-]{35}/, 'GOOGLE_API_KEY'],

    # age encryption
    [qr/AGE-SECRET-KEY-[A-Z0-9]{59}/, 'AGE_SECRET_KEY'],

    # Stripe
    [qr/sk_live_[A-Za-z0-9]{24,}/, 'STRIPE_SECRET'],
    [qr/sk_test_[A-Za-z0-9]{24,}/, 'STRIPE_TEST'],
    [qr/pk_live_[A-Za-z0-9]{24,}/, 'STRIPE_PUBLISHABLE'],

    # Twilio
    [qr/SK[a-f0-9]{32}/, 'TWILIO_KEY'],

    # SendGrid
    [qr/SG\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/, 'SENDGRID_KEY'],

    # npm / PyPI
    [qr/npm_[A-Za-z0-9]{36}/, 'NPM_TOKEN'],
    [qr/pypi-[A-Za-z0-9_-]{100,}/, 'PYPI_TOKEN'],

    # JWT tokens
    [qr/eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/, 'JWT_TOKEN'],

    # netrc/authinfo passwords (lookbehind)
    [qr/(?<=password )[^\s]+/, 'NETRC_PASSWORD'],
    [qr/(?<=passwd )[^\s]+/, 'NETRC_PASSWORD'],

    # Generic key=value patterns
    [qr/(?<=password=)[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
    [qr/(?<=password:)\s*[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
    [qr/(?<=Password=)[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
    [qr/(?<=Password:)\s*[^\s,;"'\}\[\]]+/, 'PASSWORD_VALUE'],
    [qr/(?<=secret=)[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
    [qr/(?<=secret:)\s*[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
    [qr/(?<=Secret=)[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
    [qr/(?<=Secret:)\s*[^\s,;"'\}\[\]]+/, 'SECRET_VALUE'],
    [qr/(?<=token=)[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],
    [qr/(?<=token:)\s*[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],
    [qr/(?<=Token=)[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],
    [qr/(?<=Token:)\s*[^\s,;"'\}\[\]]+/, 'TOKEN_VALUE'],

    # Private keys (multiline regex for batch mode fallback)
    [qr/-----BEGIN [A-Z ]*PRIVATE KEY-----[\s\S]*?-----END [A-Z ]*PRIVATE KEY-----/, 'PRIVATE_KEY'],
);

# Check if env value is falsy (0, false, no)
sub is_env_falsy {
    my ($val) = @_;
    return 0 unless defined $val;
    return lc($val) =~ /^(0|false|no)$/;
}

# Parse filter configuration from CLI and ENV
sub parse_filter_config {
    my $filter_arg;

    # Parse CLI arguments
    GetOptions('filter|f=s' => \$filter_arg) or exit 1;

    my ($values_enabled, $patterns_enabled);

    if (defined $filter_arg) {
        # CLI overrides ENV entirely
        my @valid_filters;
        my @invalid_filters;

        for my $f (split /,/, $filter_arg) {
            $f =~ s/^\s+|\s+$//g;  # trim whitespace
            $f = lc($f);

            if ($f eq 'all') {
                push @valid_filters, 'values', 'patterns';
            } elsif ($f eq 'values' || $f eq 'patterns') {
                push @valid_filters, $f;
            } else {
                push @invalid_filters, $f;
            }
        }

        # Warn about invalid filters
        for my $inv (@invalid_filters) {
            warn "secrets-filter: unknown filter '$inv', ignoring\n";
        }

        # Error if no valid filters
        if (@valid_filters == 0) {
            warn "secrets-filter: no valid filters specified\n";
            exit 1;
        }

        # Enable based on valid filters
        my %valid_set = map { $_ => 1 } @valid_filters;
        $values_enabled = $valid_set{values} ? 1 : 0;
        $patterns_enabled = $valid_set{patterns} ? 1 : 0;
    } else {
        # Check ENV variables (default: enabled unless explicitly disabled)
        $values_enabled = is_env_falsy($ENV{SECRETS_FILTER_VALUES}) ? 0 : 1;
        $patterns_enabled = is_env_falsy($ENV{SECRETS_FILTER_PATTERNS}) ? 0 : 1;
    }

    return ($values_enabled, $patterns_enabled);
}

# Classify a segment: N=digits, A=letters, X=mixed
sub classify_segment {
    my ($s) = @_;
    return '' unless defined $s && length $s;
    return length($s) . 'N' if $s =~ /^\d+$/;
    return length($s) . 'A' if $s =~ /^[A-Za-z]+$/;
    return length($s) . 'X';
}

# Describe token structure for redaction label
sub describe_structure {
    my ($s) = @_;
    return '' unless defined $s;

    # Very long tokens: show length (with prefix hint if available)
    if (length($s) >= $LONG_THRESHOLD) {
        for my $sep ('-', '_', '.') {
            if (index($s, $sep) != -1) {
                my @parts = split(/\Q$sep\E/, $s);
                my $first = $parts[0];
                if ($first =~ /^[a-zA-Z]+$/ || $first =~ /^(ghp|gho|ghs|ghr|npm|sk)$/) {
                    return "$first$sep...:" . length($s) . "chars";
                }
            }
        }
        return length($s) . "chars";
    }

    # Check for structured tokens
    for my $sep ('-', '.', '_') {
        if (index($s, $sep) != -1) {
            my @parts = split(/\Q$sep\E/, $s);
            if (@parts >= 2) {
                my $first = $parts[0];
                if ($first =~ /^[A-Za-z]+$/ && length($first) <= 12) {
                    my @segments = map { classify_segment($_) } @parts[1..$#parts];
                    return "$first$sep" . join($sep, @segments);
                }
                my @segments = map { classify_segment($_) } @parts;
                return join($sep, @segments);
            }
        }
    }

    return classify_segment($s);
}

# Load secrets from environment variables
sub load_secrets {
    my %secrets;

    my @explicit = qw(
        GITHUB_TOKEN GH_TOKEN GITLAB_TOKEN GLAB_TOKEN BITBUCKET_TOKEN
        AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AZURE_CLIENT_SECRET
        OPENAI_API_KEY ANTHROPIC_API_KEY CLAUDE_API_KEY
        SLACK_TOKEN SLACK_BOT_TOKEN SLACK_WEBHOOK_URL
        NPM_TOKEN PYPI_TOKEN DOCKER_PASSWORD
        DATABASE_URL REDIS_URL MONGODB_URI
        JWT_SECRET SESSION_SECRET ENCRYPTION_KEY
        SENDGRID_API_KEY TWILIO_AUTH_TOKEN STRIPE_SECRET_KEY
    );
    my %explicit_set = map { $_ => 1 } @explicit;

    for my $name (keys %ENV) {
        my $value = $ENV{$name};
        next unless defined $value && length($value) >= 8;

        if ($explicit_set{$name} ||
            $name =~ /(?:_SECRET|_PASSWORD|_TOKEN|_API_KEY|_PRIVATE_KEY|_AUTH|_CREDENTIAL)$/) {
            $secrets{$name} = $value;
        }
    }

    return \%secrets;
}

# Replace known secret values with [REDACTED:VAR_NAME:structure]
sub redact_env_values {
    my ($text, $secrets) = @_;

    # Sort by value length descending
    for my $var (sort { length($secrets->{$b}) <=> length($secrets->{$a}) } keys %$secrets) {
        my $val = $secrets->{$var};
        next unless defined $val && $val ne '';
        my $structure = describe_structure($val);
        my $replacement = "[REDACTED:$var:$structure]";
        $text =~ s/\Q$val\E/$replacement/g;
    }

    return $text;
}

# Replace known token patterns
sub redact_patterns {
    my ($text) = @_;

    for my $pattern_info (@PATTERNS) {
        my ($pattern, $label) = @$pattern_info;
        $text =~ s/$pattern/
            my $matched = $&;
            my $structure = describe_structure($matched);
            "[REDACTED:$label:$structure]"
        /ge;
    }

    # Git credential URLs: :\/\/user:password@ -> :\/\/user:[REDACTED]@
    $text =~ s{(://[^:]+:)([^@]+)(@)}{
        my $structure = describe_structure($2);
        "$1\[REDACTED:GIT_CREDENTIAL:$structure]$3"
    }ge;

    # Docker config auth: "auth": "base64" -> "auth": "[REDACTED]"
    $text =~ s{("auth":\s*")([A-Za-z0-9+/=]{20,})(")}{
        my $structure = describe_structure($2);
        "$1\[REDACTED:DOCKER_AUTH:$structure]$3"
    }ge;

    return $text;
}

# Redact a single line (respects filter settings)
sub redact_line {
    my ($line, $secrets) = @_;
    $line = redact_env_values($line, $secrets) if $filter_values;
    $line = redact_patterns($line) if $filter_patterns;
    return $line;
}

# Flush buffer with redaction
sub flush_buffer_redacted {
    my ($buffer, $secrets) = @_;
    for my $line (@$buffer) {
        print redact_line($line, $secrets);
    }
}

# Main
sub main {
    # Skip loading secrets if values filter disabled
    my $secrets = $filter_values ? load_secrets() : {};
    my $state = $STATE_NORMAL;
    my @buffer;

    while (my $line = <STDIN>) {
        # Binary detection: null byte means binary data
        if (index($line, "\0") != -1) {
            flush_buffer_redacted(\@buffer, $secrets) if @buffer;
            @buffer = ();
            print $line;
            # Passthrough rest
            while (<STDIN>) {
                print;
            }
            return;
        }

        if ($state == $STATE_NORMAL) {
            # Only use state machine for private keys if patterns filter enabled
            if ($filter_patterns && $line =~ $PRIVATE_KEY_BEGIN) {
                $state = $STATE_IN_PRIVATE_KEY;
                @buffer = ($line);
            } else {
                print redact_line($line, $secrets);
            }
        } elsif ($state == $STATE_IN_PRIVATE_KEY) {
            push @buffer, $line;

            if ($line =~ $PRIVATE_KEY_END) {
                print "[REDACTED:PRIVATE_KEY:multiline]\n";
                @buffer = ();
                $state = $STATE_NORMAL;
            } elsif (@buffer > $MAX_PRIVATE_KEY_BUFFER) {
                flush_buffer_redacted(\@buffer, $secrets);
                @buffer = ();
                $state = $STATE_NORMAL;
            }
        }
    }

    # EOF: flush remaining buffer
    flush_buffer_redacted(\@buffer, $secrets) if @buffer;
}

main();
